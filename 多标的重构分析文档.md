# LongBridge 量化交易系统 - 多标的重构分析文档

## 文档版本
- **版本**: v1.0
- **日期**: 2026-01-08
- **作者**: Claude Code Analysis

---

## 目录
1. [当前单标的架构分析](#1-当前单标的架构分析)
2. [核心问题与限制](#2-核心问题与限制)
3. [多标的架构设计方案](#3-多标的架构设计方案)
4. [重构实施方案](#4-重构实施方案)
5. [兼容性与迁移](#5-兼容性与迁移)
6. [风险与注意事项](#6-风险与注意事项)
7. [开发时间估算](#7-开发时间估算)

---

## 1. 当前单标的架构分析

### 1.1 配置层面

#### 环境变量配置 (.env.local)
当前系统使用单套环境变量配置：

```bash
# 监控标的（用于生成交易信号）
MONITOR_SYMBOL=HSI.HK

# 交易标的
LONG_SYMBOL=61604    # 做多标的（牛证）
SHORT_SYMBOL=54283   # 做空标的（熊证）

# 信号配置（4个信号，针对监控标的）
SIGNAL_BUYCALL=(RSI:6<25,MFI<15,D<25,J<-1)/3|(J<-20)
SIGNAL_SELLCALL=(RSI:6>75,MFI>85,D>75,J>100)/3|(J>110)
SIGNAL_BUYPUT=(RSI:6>75,MFI>85,D>75,J>100)/3|(J>120)
SIGNAL_SELLPUT=(RSI:6<25,MFI<15,D<25,J<0)/3|(J<-15)

# 延迟验证配置
VERIFICATION_DELAY_SECONDS_BUY=90
VERIFICATION_INDICATORS_BUY=D,EMA:5
VERIFICATION_DELAY_SECONDS_SELL=75
VERIFICATION_INDICATORS_SELL=K

# 交易金额和风险配置
TARGET_NOTIONAL=10000
MAX_POSITION_NOTIONAL=100000
MAX_DAILY_LOSS=3000
MAX_UNREALIZED_LOSS_PER_SYMBOL=5000
BUY_INTERVAL_SECONDS=90

# 其他配置
DOOMSDAY_PROTECTION=true
```

**关键问题**：
- 所有配置项都是单标的的，没有标的标识符
- 无法支持多个监控标的的独立配置
- 配置耦合度高，扩展性差

#### 配置解析 (config.trading.ts)
```typescript
export const TRADING_CONFIG: TradingConfig = {
  monitorSymbol: getStringConfig('MONITOR_SYMBOL'),        // 单个
  longSymbol: getStringConfig('LONG_SYMBOL'),              // 单个
  shortSymbol: getStringConfig('SHORT_SYMBOL'),            // 单个
  signalConfig: { /* 单套信号配置 */ },
  verificationConfig: { /* 单套验证配置 */ },
  // ... 其他单标的配置
};
```

**关键问题**：
- `TRADING_CONFIG` 是单个对象，不是数组
- 配置结构无法扩展到多标的

### 1.2 代码结构

#### 主入口 (src/index.ts)
```typescript
// 硬编码的标的符号
const LONG_SYMBOL = TRADING_CONFIG.longSymbol || '';
const SHORT_SYMBOL = TRADING_CONFIG.shortSymbol || '';
const MONITOR_SYMBOL = TRADING_CONFIG.monitorSymbol || '';

// 主循环函数 - 单标的处理
async function runOnce(context: RunOnceContext): Promise<void> {
  // 1. 获取三个标的的行情
  const [longQuote, shortQuote, monitorQuote] = await Promise.all([
    marketDataClient.getLatestQuote(LONG_SYMBOL),
    marketDataClient.getLatestQuote(SHORT_SYMBOL),
    marketDataClient.getLatestQuote(MONITOR_SYMBOL),
  ]);

  // 2. 获取监控标的的K线和指标
  const monitorCandles = await marketDataClient.getCandlesticks(
    MONITOR_SYMBOL, CANDLE_PERIOD, CANDLE_COUNT
  );
  const monitorSnapshot = buildIndicatorSnapshot(
    MONITOR_SYMBOL, monitorCandles, RSI_PERIODS, EMA_PERIODS
  );

  // 3. 生成信号（针对单个监控标的）
  const { immediateSignals, delayedSignals } = strategy.generateCloseSignals(
    monitorSnapshot, longPosition, shortPosition,
    NORMALIZED_LONG_SYMBOL, NORMALIZED_SHORT_SYMBOL
  );

  // 4. 处理和执行信号
  // ...
}

// 主循环 - 每秒执行一次
while (true) {
  await runOnce({ /* context */ });
  await sleep(INTERVAL_MS);
}
```

**关键问题**：
- `runOnce` 只处理单个监控标的
- 标的符号硬编码为常量
- 无法并发处理多个监控标的

#### 状态管理 (LastState)
```typescript
interface LastState {
  longPrice: number | null;              // 单对标的价格
  shortPrice: number | null;
  signal: string | null;                 // 单个信号状态
  pendingDelayedSignals: Signal[];       // 混合所有监控标的的待验证信号
  monitorValues: MonitorValues | null;   // 单个监控标的的指标值
  cachedAccount: AccountSnapshot | null;
  cachedPositions: Position[];
  cachedTradingDayInfo: { /* ... */ } | null;
  lastMonitorSnapshot: IndicatorSnapshot | null;  // 单个监控标的的快照
}
```

**关键问题**：
- 状态结构只能存储单个监控标的的数据
- `pendingDelayedSignals` 不区分监控标的
- 多个监控标的的信号会混在一起

### 1.3 核心模块分析

#### Strategy (策略模块)
```typescript
export const createHangSengMultiIndicatorStrategy = ({
  signalConfig,           // 单套信号配置
  verificationConfig,     // 单套验证配置
}) => {
  return {
    generateCloseSignals: (
      state: IndicatorSnapshot,          // 单个监控标的的指标
      longPosition: Position | null,     // 单个做多标的
      shortPosition: Position | null,    // 单个做空标的
      longSymbol: string,
      shortSymbol: string,
    ) => {
      // 根据监控标的指标生成信号
      // 信号对应到固定的 longSymbol 和 shortSymbol
    }
  };
};
```

**关键问题**：
- 策略实例绑定单套配置
- 无法处理多个监控标的的不同策略

#### OrderRecorder (订单记录模块)
```typescript
export const createOrderRecorder = (deps) => {
  const storage = createOrderStorage();  // 内部状态

  return {
    _longBuyOrders: [],   // 单个做多标的的买入订单
    _shortBuyOrders: [],  // 单个做空标的的买入订单
    // ...
  };
};
```

**关键问题**：
- 订单记录只支持一对 long/short 标的
- 无法区分多个监控标的的订单

#### RiskChecker (风险检查模块)
```typescript
export const createRiskChecker = (deps) => {
  const unrealizedLossData: Map<string, UnrealizedLossData> = new Map();

  return {
    checkBeforeOrder: (account, positions, signal, orderNotional, ...) => {
      // 使用全局的 TRADING_CONFIG.maxDailyLoss
      // 无法区分不同监控标的的风险限制
    },
    // ...
  };
};
```

**关键问题**：
- `unrealizedLossData` 虽然是 Map，但配置是全局单一的
- 风险检查使用全局配置，无法针对不同监控标的设置不同限制

### 1.4 数据流分析

```
1秒循环 START
    ↓
检查交易时段
    ↓
获取行情（longQuote, shortQuote, monitorQuote）
    ↓
获取监控标的K线数据
    ↓
计算监控标的指标（RSI, KDJ, MACD, MFI, EMA）
    ↓
生成交易信号（针对 long/short 标的）
    ↓
记录验证历史
    ↓
验证待验证信号
    ↓
风险检查（6项固定顺序）
    ↓
处理卖出信号
    ↓
执行订单
    ↓
监控未成交订单
    ↓
1秒循环 END
```

**关键特征**：
- 单线性流程，每次循环只处理一个监控标的
- 所有模块都假设只有一个监控标的
- 无法并发处理多个监控标的

---

## 2. 核心问题与限制

### 2.1 配置耦合

**问题**：
- 环境变量是平面结构，没有标的分组概念
- 单个 `TRADING_CONFIG` 对象，无法表达多标的配置
- 添加新监控标的需要修改代码

**影响**：
- 无法通过配置文件动态添加监控标的
- 配置管理混乱，难以维护

### 2.2 状态混合

**问题**：
- `LastState` 只能存储单个监控标的的状态
- `pendingDelayedSignals` 混合所有监控标的的信号
- 无法区分不同监控标的的验证历史

**影响**：
- 验证逻辑可能错误（混用不同监控标的的指标值）
- 状态管理混乱

### 2.3 硬编码依赖

**问题**：
- `LONG_SYMBOL`, `SHORT_SYMBOL`, `MONITOR_SYMBOL` 硬编码为常量
- 模块内部直接引用 `TRADING_CONFIG` 全局对象
- 无法动态创建多个策略实例

**影响**：
- 代码扩展性差
- 无法实现多标的并发处理

### 2.4 订单记录隔离

**问题**：
- `OrderRecorder` 只支持一对 long/short 标的
- 订单过滤算法无法区分不同监控标的的订单

**影响**：
- 多个监控标的交易同一标的时订单记录会冲突
- 成本价计算错误

### 2.5 风险检查全局化

**问题**：
- 风险限制（MAX_DAILY_LOSS, MAX_POSITION_NOTIONAL）是全局的
- 无法为不同监控标的设置不同的风险参数

**影响**：
- 风险控制粒度粗
- 无法实现精细化风险管理

---

## 3. 多标的架构设计方案

### 3.1 核心设计原则

1. **配置数组化**：监控标的配置从单个对象变为数组
2. **标的隔离**：每个监控标的拥有独立的状态、订单记录、策略实例
3. **依赖注入**：模块通过依赖注入接收配置，而非引用全局对象
4. **并发处理**：主循环并发处理多个监控标的
5. **向后兼容**：支持单标的配置格式（自动转换为数组）

### 3.2 配置结构设计

#### 3.2.1 环境变量结构（新增多标的支持）

**方案A：索引编号方式**（推荐）
```bash
# ============ 监控标的 1 ============
MONITOR_SYMBOL_1=HSI.HK
LONG_SYMBOL_1=61604
SHORT_SYMBOL_1=54283

# 信号配置
SIGNAL_BUYCALL_1=(RSI:6<25,MFI<15,D<25,J<-1)/3|(J<-20)
SIGNAL_SELLCALL_1=(RSI:6>75,MFI>85,D>75,J>100)/3|(J>110)
SIGNAL_BUYPUT_1=(RSI:6>75,MFI>85,D>75,J>100)/3|(J>120)
SIGNAL_SELLPUT_1=(RSI:6<25,MFI<15,D<25,J<0)/3|(J<-15)

# 延迟验证配置
VERIFICATION_DELAY_SECONDS_BUY_1=90
VERIFICATION_INDICATORS_BUY_1=D,EMA:5
VERIFICATION_DELAY_SECONDS_SELL_1=75
VERIFICATION_INDICATORS_SELL_1=K

# 交易金额和风险配置
TARGET_NOTIONAL_1=10000
MAX_POSITION_NOTIONAL_1=100000
MAX_DAILY_LOSS_1=3000
MAX_UNREALIZED_LOSS_PER_SYMBOL_1=5000
BUY_INTERVAL_SECONDS_1=90

# ============ 监控标的 2 ============
MONITOR_SYMBOL_2=02318.HK
LONG_SYMBOL_2=61234
SHORT_SYMBOL_2=54321

# 信号配置
SIGNAL_BUYCALL_2=(RSI:14<30,MFI<20,D<30)/2
SIGNAL_SELLCALL_2=(RSI:14>70,MFI>80,D>70)/2
SIGNAL_BUYPUT_2=(RSI:14>70,MFI>80,D>70)/2
SIGNAL_SELLPUT_2=(RSI:14<30,MFI<20,D<30)/2

# 延迟验证配置
VERIFICATION_DELAY_SECONDS_BUY_2=60
VERIFICATION_INDICATORS_BUY_2=K,J
VERIFICATION_DELAY_SECONDS_SELL_2=60
VERIFICATION_INDICATORS_SELL_2=D,DIF

# 交易金额和风险配置
TARGET_NOTIONAL_2=15000
MAX_POSITION_NOTIONAL_2=150000
MAX_DAILY_LOSS_2=5000
MAX_UNREALIZED_LOSS_PER_SYMBOL_2=8000
BUY_INTERVAL_SECONDS_2=120

# ============ 全局配置 ============
# 监控标的数量（必需）
MONITOR_COUNT=2

# 末日保护（全局）
DOOMSDAY_PROTECTION=true
```

**优点**：
- 简单直观，易于理解
- 兼容现有单标的配置（无索引 = 索引1）
- 环境变量命名清晰

**缺点**：
- 环境变量较多
- 添加新标的需要手动编号

**方案B：JSON配置文件方式**（备选）
```bash
# .env.local（简化）
LONGPORT_APP_KEY=xxx
LONGPORT_APP_SECRET=xxx
LONGPORT_ACCESS_TOKEN=xxx
LONGPORT_REGION=cn

# 监控标的配置文件路径
MONITOR_CONFIG_FILE=./config/monitors.json
```

```json
// config/monitors.json
[
  {
    "monitorSymbol": "HSI.HK",
    "longSymbol": "61604",
    "shortSymbol": "54283",
    "signalConfig": {
      "buycall": "(RSI:6<25,MFI<15,D<25,J<-1)/3|(J<-20)",
      "sellcall": "(RSI:6>75,MFI>85,D>75,J>100)/3|(J>110)",
      "buyput": "(RSI:6>75,MFI>85,D>75,J>100)/3|(J>120)",
      "sellput": "(RSI:6<25,MFI<15,D<25,J<0)/3|(J<-15)"
    },
    "verificationConfig": {
      "buy": {
        "delaySeconds": 90,
        "indicators": ["D", "EMA:5"]
      },
      "sell": {
        "delaySeconds": 75,
        "indicators": ["K"]
      }
    },
    "targetNotional": 10000,
    "maxPositionNotional": 100000,
    "maxDailyLoss": 3000,
    "maxUnrealizedLossPerSymbol": 5000,
    "buyIntervalSeconds": 90
  },
  {
    "monitorSymbol": "02318.HK",
    "longSymbol": "61234",
    "shortSymbol": "54321",
    "signalConfig": {
      "buycall": "(RSI:14<30,MFI<20,D<30)/2",
      "sellcall": "(RSI:14>70,MFI>80,D>70)/2",
      "buyput": "(RSI:14>70,MFI>80,D>70)/2",
      "sellput": "(RSI:14<30,MFI<20,D<30)/2"
    },
    "verificationConfig": {
      "buy": {
        "delaySeconds": 60,
        "indicators": ["K", "J"]
      },
      "sell": {
        "delaySeconds": 60,
        "indicators": ["D", "DIF"]
      }
    },
    "targetNotional": 15000,
    "maxPositionNotional": 150000,
    "maxDailyLoss": 5000,
    "maxUnrealizedLossPerSymbol": 8000,
    "buyIntervalSeconds": 120
  }
]
```

**优点**：
- 配置结构清晰
- 易于动态添加/删除监控标的
- 支持复杂配置

**缺点**：
- 需要额外的 JSON 文件
- 配置分散在多个文件

**推荐方案**：
- **初期使用方案A（索引编号）**，保持与现有配置风格一致
- **长期可升级到方案B（JSON配置）**，提升可维护性

#### 3.2.2 配置类型定义（新增）

```typescript
// src/types/index.ts

/**
 * 单个监控标的的完整配置
 */
export type MonitorConfig = {
  readonly monitorSymbol: string;
  readonly longSymbol: string;
  readonly shortSymbol: string;
  readonly targetNotional: number;
  readonly longLotSize: number | null;
  readonly shortLotSize: number | null;
  readonly maxPositionNotional: number;
  readonly maxDailyLoss: number;
  readonly maxUnrealizedLossPerSymbol: number;
  readonly buyIntervalSeconds: number;
  readonly verificationConfig: VerificationConfig;
  readonly signalConfig: SignalConfigSet;
};

/**
 * 全局配置（非监控标的特定）
 */
export type GlobalConfig = {
  readonly doomsdayProtection: boolean;
  readonly debug: boolean;
};

/**
 * 多标的交易配置
 */
export type MultiMonitorTradingConfig = {
  readonly monitors: ReadonlyArray<MonitorConfig>;  // 监控标的数组
  readonly global: GlobalConfig;                     // 全局配置
};
```

#### 3.2.3 配置解析（重构）

```typescript
// src/config/config.trading.ts

/**
 * 解析单个监控标的的配置（从带索引的环境变量）
 */
function parseMonitorConfig(index: number): MonitorConfig | null {
  const suffix = index > 0 ? `_${index}` : '';  // 索引0或无索引时为空后缀（兼容旧配置）

  const monitorSymbol = getStringConfig(`MONITOR_SYMBOL${suffix}`);
  if (!monitorSymbol) {
    return null;  // 该索引无配置
  }

  return {
    monitorSymbol,
    longSymbol: getStringConfig(`LONG_SYMBOL${suffix}`) || '',
    shortSymbol: getStringConfig(`SHORT_SYMBOL${suffix}`) || '',
    targetNotional: getNumberConfig(`TARGET_NOTIONAL${suffix}`, 1) || 10000,
    longLotSize: getNumberConfig(`LONG_LOT_SIZE${suffix}`, 1),
    shortLotSize: getNumberConfig(`SHORT_LOT_SIZE${suffix}`, 1),
    maxPositionNotional: getNumberConfig(`MAX_POSITION_NOTIONAL${suffix}`, 1) || 100000,
    maxDailyLoss: getNumberConfig(`MAX_DAILY_LOSS${suffix}`, 0) || 0,
    maxUnrealizedLossPerSymbol: getNumberConfig(`MAX_UNREALIZED_LOSS_PER_SYMBOL${suffix}`, 0) || 0,
    buyIntervalSeconds: getNumberConfig(`BUY_INTERVAL_SECONDS${suffix}`, 10) || 60,
    verificationConfig: {
      buy: {
        delaySeconds: parseVerificationDelay(`VERIFICATION_DELAY_SECONDS_BUY${suffix}`, 60),
        indicators: parseVerificationIndicators(`VERIFICATION_INDICATORS_BUY${suffix}`),
      },
      sell: {
        delaySeconds: parseVerificationDelay(`VERIFICATION_DELAY_SECONDS_SELL${suffix}`, 60),
        indicators: parseVerificationIndicators(`VERIFICATION_INDICATORS_SELL${suffix}`),
      },
    },
    signalConfig: {
      buycall: parseSignalConfig(getStringConfig(`SIGNAL_BUYCALL${suffix}`) || ''),
      sellcall: parseSignalConfig(getStringConfig(`SIGNAL_SELLCALL${suffix}`) || ''),
      buyput: parseSignalConfig(getStringConfig(`SIGNAL_BUYPUT${suffix}`) || ''),
      sellput: parseSignalConfig(getStringConfig(`SIGNAL_SELLPUT${suffix}`) || ''),
    },
  };
}

/**
 * 解析所有监控标的配置
 */
export const MULTI_MONITOR_TRADING_CONFIG: MultiMonitorTradingConfig = (() => {
  const monitors: MonitorConfig[] = [];

  // 方法1: 使用 MONITOR_COUNT 环境变量
  const monitorCount = getNumberConfig('MONITOR_COUNT', 1);
  if (monitorCount && monitorCount > 0) {
    for (let i = 1; i <= monitorCount; i++) {
      const config = parseMonitorConfig(i);
      if (config) {
        monitors.push(config);
      }
    }
  }

  // 方法2: 如果 MONITOR_COUNT 未设置，尝试解析无索引配置（向后兼容）
  if (monitors.length === 0) {
    const legacyConfig = parseMonitorConfig(0);  // 索引0表示无后缀
    if (legacyConfig) {
      monitors.push(legacyConfig);
    }
  }

  // 方法3: 如果仍然没有配置，尝试按索引自动发现（索引1开始）
  if (monitors.length === 0) {
    for (let i = 1; i <= 10; i++) {  // 最多尝试10个
      const config = parseMonitorConfig(i);
      if (config) {
        monitors.push(config);
      } else {
        break;  // 遇到第一个空配置就停止
      }
    }
  }

  return {
    monitors,
    global: {
      doomsdayProtection: getBooleanConfig('DOOMSDAY_PROTECTION', true),
      debug: getBooleanConfig('DEBUG', false),
    },
  };
})();

// 导出（向后兼容）
export const TRADING_CONFIG: TradingConfig =
  MULTI_MONITOR_TRADING_CONFIG.monitors[0] || ({} as TradingConfig);
```

### 3.3 状态管理设计

#### 3.3.1 监控标的状态（新增）

```typescript
// src/types/index.ts

/**
 * 单个监控标的的状态
 */
export interface MonitorState {
  monitorSymbol: string;                      // 监控标的符号
  longSymbol: string;                         // 做多标的符号
  shortSymbol: string;                        // 做空标的符号
  longPrice: number | null;                   // 做多标的价格
  shortPrice: number | null;                  // 做空标的价格
  signal: string | null;                      // 当前信号状态
  pendingDelayedSignals: Signal[];            // 该监控标的的待验证信号
  monitorValues: MonitorValues | null;        // 监控标的指标值
  lastMonitorSnapshot: IndicatorSnapshot | null;  // 上次指标快照
}

/**
 * 全局状态（修改）
 */
export interface LastState {
  canTrade: boolean | null;                   // 是否可交易
  isHalfDay: boolean | null;                  // 是否半日市
  cachedAccount: AccountSnapshot | null;      // 缓存的账户信息
  cachedPositions: Position[];                // 缓存的持仓信息
  cachedTradingDayInfo: {                     // 缓存的交易日信息
    isTradingDay: boolean;
    isHalfDay: boolean;
    checkDate: string;
  } | null;

  // 新增：监控标的状态数组（替代原有的单标的状态）
  monitorStates: Map<string, MonitorState>;   // key: monitorSymbol
}
```

#### 3.3.2 状态初始化

```typescript
// src/index.ts

/**
 * 创建监控标的状态
 */
function createMonitorState(monitorConfig: MonitorConfig): MonitorState {
  return {
    monitorSymbol: monitorConfig.monitorSymbol,
    longSymbol: monitorConfig.longSymbol,
    shortSymbol: monitorConfig.shortSymbol,
    longPrice: null,
    shortPrice: null,
    signal: null,
    pendingDelayedSignals: [],
    monitorValues: null,
    lastMonitorSnapshot: null,
  };
}

/**
 * 初始化全局状态
 */
const lastState: LastState = {
  canTrade: null,
  isHalfDay: null,
  cachedAccount: null,
  cachedPositions: [],
  cachedTradingDayInfo: null,
  monitorStates: new Map(
    MULTI_MONITOR_TRADING_CONFIG.monitors.map(config => [
      config.monitorSymbol,
      createMonitorState(config),
    ])
  ),
};
```

### 3.4 模块隔离设计

#### 3.4.1 策略实例隔离

**问题**：当前策略是全局单例，无法支持不同监控标的的不同配置

**解决方案**：为每个监控标的创建独立的策略实例

```typescript
// src/index.ts

/**
 * 监控标的上下文（新增）
 */
interface MonitorContext {
  config: MonitorConfig;                             // 该监控标的的配置
  state: MonitorState;                               // 该监控标的的状态
  strategy: HangSengMultiIndicatorStrategy;          // 该监控标的的策略实例
  orderRecorder: OrderRecorder;                      // 该监控标的的订单记录器
  signalVerificationManager: SignalVerificationManager;  // 该监控标的的信号验证管理器
}

/**
 * 创建监控标的上下文
 */
function createMonitorContext(
  config: MonitorConfig,
  state: MonitorState,
  trader: Trader,
): MonitorContext {
  return {
    config,
    state,
    strategy: createHangSengMultiIndicatorStrategy({
      signalConfig: config.signalConfig,
      verificationConfig: config.verificationConfig,
    }),
    orderRecorder: createOrderRecorder({ trader }),
    signalVerificationManager: createSignalVerificationManager(
      config.verificationConfig
    ),
  };
}

// 主程序初始化
const monitorContexts: Map<string, MonitorContext> = new Map();

for (const config of MULTI_MONITOR_TRADING_CONFIG.monitors) {
  const state = lastState.monitorStates.get(config.monitorSymbol);
  if (!state) continue;

  const context = createMonitorContext(config, state, trader);
  monitorContexts.set(config.monitorSymbol, context);
}
```

#### 3.4.2 订单记录隔离

**问题**：当前 `OrderRecorder` 只支持一对 long/short 标的

**解决方案1：多实例方式**（推荐）
每个监控标的拥有独立的 `OrderRecorder` 实例：

```typescript
// 每个 MonitorContext 中包含独立的 OrderRecorder
interface MonitorContext {
  // ...
  orderRecorder: OrderRecorder;  // 独立实例
}

// 初始化时创建
const context = createMonitorContext(config, state, trader);
// context.orderRecorder 只记录该监控标的相关的订单
```

**解决方案2：订单记录器内部隔离**（备选）
改造 `OrderRecorder` 支持多对标的：

```typescript
// src/core/orderRecorder/orderStorage.ts

export const createOrderStorage = () => {
  // 使用 Map 代替单一数组
  const buyOrdersMap: Map<string, OrderRecord[]> = new Map();  // key: symbol

  return {
    getBuyOrdersList(symbol: string): OrderRecord[] {
      return buyOrdersMap.get(symbol) || [];
    },

    setBuyOrdersList(symbol: string, orders: OrderRecord[]): void {
      buyOrdersMap.set(symbol, orders);
    },

    // ... 其他方法
  };
};
```

**推荐使用方案1**：
- 代码改动较小
- 数据隔离更彻底
- 符合当前架构设计

#### 3.4.3 风险检查器适配

**问题**：`RiskChecker` 的配置是全局的（MAX_DAILY_LOSS 等）

**解决方案**：为每个监控标的创建独立的风险检查器

```typescript
// src/core/risk/index.ts

export const createRiskChecker = (deps: RiskCheckerDeps = {}): RiskChecker => {
  // 从 deps 中接收配置，而非引用全局 TRADING_CONFIG
  const maxDailyLoss = deps.options?.maxDailyLoss ?? 0;
  const maxPositionNotional = deps.options?.maxPositionNotional ?? 0;
  const maxUnrealizedLossPerSymbol = deps.options?.maxUnrealizedLossPerSymbol ?? 0;

  // ... 使用传入的配置
};

// 主程序初始化
interface MonitorContext {
  // ...
  riskChecker: RiskChecker;  // 新增：每个监控标的独立的风险检查器
}

function createMonitorContext(
  config: MonitorConfig,
  state: MonitorState,
  trader: Trader,
): MonitorContext {
  return {
    config,
    state,
    strategy: createHangSengMultiIndicatorStrategy({ /* ... */ }),
    orderRecorder: createOrderRecorder({ trader }),
    signalVerificationManager: createSignalVerificationManager(/* ... */),
    riskChecker: createRiskChecker({
      options: {
        maxDailyLoss: config.maxDailyLoss,
        maxPositionNotional: config.maxPositionNotional,
        maxUnrealizedLossPerSymbol: config.maxUnrealizedLossPerSymbol,
      },
    }),  // 使用该监控标的的风险配置
  };
}
```

### 3.5 主循环并发处理设计

#### 3.5.1 单标的处理函数（新增）

```typescript
// src/index.ts

/**
 * 处理单个监控标的（runOnce 的拆分版本）
 */
async function processMonitor(
  monitorSymbol: string,
  context: {
    monitorContext: MonitorContext;
    marketDataClient: MarketDataClient;
    trader: Trader;
    globalState: LastState;
    marketMonitor: MarketMonitor;
    doomsdayProtection: DoomsdayProtection;
    unrealizedLossMonitor: UnrealizedLossMonitor;
    signalProcessor: SignalProcessor;
    currentTime: Date;
    isHalfDay: boolean;
    canTradeNow: boolean;
  },
): Promise<void> {
  const { monitorContext, marketDataClient, trader, globalState, currentTime, canTradeNow } = context;
  const { config, state, strategy, orderRecorder, signalVerificationManager, riskChecker } = monitorContext;

  const LONG_SYMBOL = config.longSymbol;
  const SHORT_SYMBOL = config.shortSymbol;
  const MONITOR_SYMBOL = config.monitorSymbol;

  // 1. 获取行情
  const [longQuote, shortQuote, monitorQuote] = await Promise.all([
    marketDataClient.getLatestQuote(LONG_SYMBOL).catch(() => null),
    marketDataClient.getLatestQuote(SHORT_SYMBOL).catch(() => null),
    marketDataClient.getLatestQuote(MONITOR_SYMBOL).catch(() => null),
  ]);

  // 2. 获取K线和计算指标
  const monitorCandles = await marketDataClient
    .getCandlesticks(MONITOR_SYMBOL, CANDLE_PERIOD, CANDLE_COUNT)
    .catch(() => null);

  if (!monitorCandles || monitorCandles.length === 0) {
    logger.warn(`未获取到监控标的 ${MONITOR_SYMBOL} K线数据`);
    return;
  }

  const rsiPeriods = extractRsiPeriodsWithDefault(config.signalConfig);
  const emaPeriods = extractEmaPeriods(config.verificationConfig);

  const monitorSnapshot = buildIndicatorSnapshot(
    MONITOR_SYMBOL,
    monitorCandles as CandleData[],
    rsiPeriods,
    emaPeriods,
  );

  // 3. 监控指标变化
  context.marketMonitor.monitorIndicatorChanges(
    monitorSnapshot,
    monitorQuote,
    MONITOR_SYMBOL,
    emaPeriods,
    rsiPeriods,
    state,  // 使用该监控标的的独立状态
  );

  // 4. 记录验证历史
  signalVerificationManager.recordVerificationHistory(monitorSnapshot, state);

  // 5. 获取持仓
  const { longPosition, shortPosition } = getPositions(
    globalState.cachedPositions,
    LONG_SYMBOL,
    SHORT_SYMBOL,
  );

  // 6. 生成信号
  const { immediateSignals, delayedSignals } = strategy.generateCloseSignals(
    monitorSnapshot,
    longPosition,
    shortPosition,
    LONG_SYMBOL,
    SHORT_SYMBOL,
  );

  // 7. 处理延迟验证
  signalVerificationManager.addDelayedSignals(delayedSignals, state);
  const verifiedSignals = signalVerificationManager.verifyPendingSignals(
    state,
    longQuote,
    shortQuote,
  );

  const tradingSignals = [...immediateSignals, ...verifiedSignals];

  // 8. 风险检查和信号处理
  // ... (使用 monitorContext 中的 riskChecker)

  // 9. 执行交易
  // ...
}
```

#### 3.5.2 主循环并发调度

```typescript
// src/index.ts

/**
 * 主循环：并发处理所有监控标的
 */
async function runOnce(context: RunOnceContext): Promise<void> {
  const {
    marketDataClient,
    trader,
    lastState,
    marketMonitor,
    doomsdayProtection,
    unrealizedLossMonitor,
    signalProcessor,
    monitorContexts,
  } = context;

  // 1. 全局状态检查（交易时段、交易日等）
  const currentTime = new Date();
  const canTradeNow = /* ... 判断逻辑 */;
  const isHalfDay = /* ... 判断逻辑 */;

  if (!canTradeNow) {
    return;
  }

  // 2. 并发处理所有监控标的
  const monitorTasks = Array.from(monitorContexts.entries()).map(
    ([monitorSymbol, monitorContext]) =>
      processMonitor(monitorSymbol, {
        monitorContext,
        marketDataClient,
        trader,
        globalState: lastState,
        marketMonitor,
        doomsdayProtection,
        unrealizedLossMonitor,
        signalProcessor,
        currentTime,
        isHalfDay,
        canTradeNow,
      }).catch((err) => {
        logger.error(`处理监控标的 ${monitorSymbol} 失败`, formatError(err));
      })
  );

  await Promise.allSettled(monitorTasks);

  // 3. 全局操作（末日保护、账户更新等）
  // ...
}
```

**关键优势**：
- **并发执行**：多个监控标的的行情获取和指标计算并发进行
- **隔离错误**：单个监控标的的错误不影响其他监控标的
- **性能提升**：充分利用异步 I/O

---

## 4. 重构实施方案

### 4.1 实施步骤概览

```
阶段1: 配置层重构（1-2天）
  └─ 环境变量解析
  └─ 类型定义
  └─ 配置验证

阶段2: 状态管理重构（1天）
  └─ LastState 结构调整
  └─ MonitorState 定义
  └─ 状态初始化

阶段3: 核心模块适配（3-4天）
  └─ Strategy 依赖注入
  └─ OrderRecorder 多实例
  └─ RiskChecker 配置化
  └─ SignalVerification 隔离

阶段4: 主循环重构（2-3天）
  └─ processMonitor 函数
  └─ 并发调度
  └─ 错误处理

阶段5: 测试和验证（2-3天）
  └─ 单元测试
  └─ 集成测试
  └─ 回归测试

总计: 9-13天
```

### 4.2 详细实施计划

#### 阶段1: 配置层重构

**文件变更**：
1. `src/config/config.trading.ts`
2. `src/types/index.ts`
3. `.env.example`

**任务清单**：
- [ ] 定义 `MonitorConfig` 类型
- [ ] 定义 `MultiMonitorTradingConfig` 类型
- [ ] 实现 `parseMonitorConfig(index)` 函数
- [ ] 实现配置自动发现逻辑（支持 MONITOR_COUNT 或自动扫描）
- [ ] 更新 `.env.example` 文档
- [ ] 实现向后兼容逻辑（无索引配置自动转换）
- [ ] 添加配置验证（重复标的检测、必填项检查）

**示例代码**：
```typescript
// src/config/config.trading.ts

/**
 * 解析单个监控标的配置
 */
function parseMonitorConfig(index: number): MonitorConfig | null {
  const suffix = index === 0 ? '' : `_${index}`;

  const monitorSymbol = getStringConfig(`MONITOR_SYMBOL${suffix}`);
  if (!monitorSymbol) {
    return null;
  }

  // ... 解析其他字段

  return {
    monitorSymbol,
    longSymbol,
    shortSymbol,
    // ... 其他配置
  };
}

/**
 * 自动发现并解析所有监控标的配置
 */
export const MULTI_MONITOR_TRADING_CONFIG: MultiMonitorTradingConfig = (() => {
  const monitors: MonitorConfig[] = [];

  // 策略1: 使用 MONITOR_COUNT
  const count = getNumberConfig('MONITOR_COUNT', 1);
  if (count && count > 0) {
    for (let i = 1; i <= count; i++) {
      const config = parseMonitorConfig(i);
      if (config) monitors.push(config);
    }
  }

  // 策略2: 向后兼容（无索引）
  if (monitors.length === 0) {
    const legacy = parseMonitorConfig(0);
    if (legacy) monitors.push(legacy);
  }

  // 策略3: 自动扫描（最多10个）
  if (monitors.length === 0) {
    for (let i = 1; i <= 10; i++) {
      const config = parseMonitorConfig(i);
      if (config) {
        monitors.push(config);
      } else {
        break;
      }
    }
  }

  return {
    monitors,
    global: {
      doomsdayProtection: getBooleanConfig('DOOMSDAY_PROTECTION', true),
      debug: getBooleanConfig('DEBUG', false),
    },
  };
})();
```

**验证标准**：
- 单标的配置（无索引）能正常解析
- 多标的配置（带索引）能正常解析
- 配置缺失时有明确错误提示
- 重复监控标的能被检测并报错

#### 阶段2: 状态管理重构

**文件变更**：
1. `src/types/index.ts`
2. `src/index.ts`

**任务清单**：
- [ ] 定义 `MonitorState` 接口
- [ ] 修改 `LastState` 接口（移除单标的字段，新增 `monitorStates`）
- [ ] 实现 `createMonitorState()` 工厂函数
- [ ] 更新状态初始化代码
- [ ] 更新所有引用 `lastState` 的代码（切换到 `monitorState`）

**示例代码**：
```typescript
// src/types/index.ts

export interface MonitorState {
  monitorSymbol: string;
  longSymbol: string;
  shortSymbol: string;
  longPrice: number | null;
  shortPrice: number | null;
  signal: string | null;
  pendingDelayedSignals: Signal[];
  monitorValues: MonitorValues | null;
  lastMonitorSnapshot: IndicatorSnapshot | null;
}

export interface LastState {
  canTrade: boolean | null;
  isHalfDay: boolean | null;
  cachedAccount: AccountSnapshot | null;
  cachedPositions: Position[];
  cachedTradingDayInfo: {
    isTradingDay: boolean;
    isHalfDay: boolean;
    checkDate: string;
  } | null;
  monitorStates: Map<string, MonitorState>;  // 新增
}

// src/index.ts

function createMonitorState(config: MonitorConfig): MonitorState {
  return {
    monitorSymbol: config.monitorSymbol,
    longSymbol: config.longSymbol,
    shortSymbol: config.shortSymbol,
    longPrice: null,
    shortPrice: null,
    signal: null,
    pendingDelayedSignals: [],
    monitorValues: null,
    lastMonitorSnapshot: null,
  };
}

const lastState: LastState = {
  canTrade: null,
  isHalfDay: null,
  cachedAccount: null,
  cachedPositions: [],
  cachedTradingDayInfo: null,
  monitorStates: new Map(
    MULTI_MONITOR_TRADING_CONFIG.monitors.map(config => [
      config.monitorSymbol,
      createMonitorState(config),
    ])
  ),
};
```

**验证标准**：
- `lastState.monitorStates` 包含所有监控标的的状态
- 每个 `MonitorState` 正确初始化
- 状态访问逻辑正确（通过 `monitorSymbol` 索引）

#### 阶段3: 核心模块适配

**3.1 Strategy 依赖注入**

**文件变更**：
- `src/core/strategy/index.ts`（无需修改，已支持依赖注入）
- `src/index.ts`（为每个监控标的创建独立实例）

**任务清单**：
- [ ] 确认 `createHangSengMultiIndicatorStrategy` 不引用全局配置
- [ ] 在 `MonitorContext` 中为每个监控标的创建独立策略实例
- [ ] 测试多个策略实例的隔离性

**示例代码**：
```typescript
// src/index.ts

interface MonitorContext {
  config: MonitorConfig;
  state: MonitorState;
  strategy: HangSengMultiIndicatorStrategy;  // 独立实例
  orderRecorder: OrderRecorder;
  signalVerificationManager: SignalVerificationManager;
  riskChecker: RiskChecker;
}

function createMonitorContext(
  config: MonitorConfig,
  state: MonitorState,
  trader: Trader,
): MonitorContext {
  return {
    config,
    state,
    strategy: createHangSengMultiIndicatorStrategy({
      signalConfig: config.signalConfig,          // 该监控标的的配置
      verificationConfig: config.verificationConfig,
    }),
    orderRecorder: createOrderRecorder({ trader }),
    signalVerificationManager: createSignalVerificationManager(
      config.verificationConfig
    ),
    riskChecker: createRiskChecker({
      options: {
        maxDailyLoss: config.maxDailyLoss,
        maxPositionNotional: config.maxPositionNotional,
        maxUnrealizedLossPerSymbol: config.maxUnrealizedLossPerSymbol,
      },
    }),
  };
}
```

**3.2 OrderRecorder 多实例**

**文件变更**：
- `src/core/orderRecorder/index.ts`（确认支持多实例）
- `src/index.ts`（为每个监控标的创建独立实例）

**任务清单**：
- [ ] 确认 `OrderRecorder` 不共享全局状态
- [ ] 为每个监控标的创建独立 `OrderRecorder` 实例
- [ ] 测试多个实例的订单记录隔离

**验证**：
- 监控标的1的订单不影响监控标的2的订单记录
- 订单过滤算法正确（针对各自的 long/short 标的）

**3.3 RiskChecker 配置化**

**文件变更**：
- `src/core/risk/index.ts`
- `src/core/risk/types.ts`

**任务清单**：
- [ ] 修改 `createRiskChecker` 接受配置参数
- [ ] 移除内部对 `TRADING_CONFIG` 的直接引用
- [ ] 为每个监控标的创建独立 `RiskChecker` 实例
- [ ] 测试风险限制隔离（不同监控标的的限制独立）

**示例代码**：
```typescript
// src/core/risk/index.ts

export const createRiskChecker = (deps: RiskCheckerDeps = {}): RiskChecker => {
  // 从 deps 接收配置
  const maxDailyLoss = deps.options?.maxDailyLoss ?? 0;
  const maxPositionNotional = deps.options?.maxPositionNotional ?? 0;
  const maxUnrealizedLossPerSymbol = deps.options?.maxUnrealizedLossPerSymbol ?? 0;

  // 使用传入的配置，而非 TRADING_CONFIG
  // ...
};
```

**3.4 SignalVerification 隔离**

**文件变更**：
- `src/core/signalVerification/index.ts`（已支持独立实例）
- `src/index.ts`（为每个监控标的创建独立实例）

**任务清单**：
- [ ] 确认 `SignalVerificationManager` 使用传入的 `state`
- [ ] 为每个监控标的创建独立实例
- [ ] 测试验证历史隔离

#### 阶段4: 主循环重构

**文件变更**：
- `src/index.ts`

**任务清单**：
- [ ] 实现 `processMonitor()` 函数（处理单个监控标的）
- [ ] 重构 `runOnce()` 函数（并发调度所有监控标的）
- [ ] 实现错误处理和日志记录
- [ ] 实现 `MonitorContext` 的初始化
- [ ] 测试并发执行的正确性

**示例代码**：
```typescript
// src/index.ts

/**
 * 处理单个监控标的
 */
async function processMonitor(
  monitorSymbol: string,
  context: {
    monitorContext: MonitorContext;
    marketDataClient: MarketDataClient;
    trader: Trader;
    globalState: LastState;
    marketMonitor: MarketMonitor;
    doomsdayProtection: DoomsdayProtection;
    unrealizedLossMonitor: UnrealizedLossMonitor;
    signalProcessor: SignalProcessor;
    currentTime: Date;
    isHalfDay: boolean;
    canTradeNow: boolean;
  },
): Promise<void> {
  const { monitorContext, marketDataClient } = context;
  const { config, state, strategy } = monitorContext;

  // 1. 获取行情
  const [longQuote, shortQuote, monitorQuote] = await Promise.all([
    marketDataClient.getLatestQuote(config.longSymbol).catch(() => null),
    marketDataClient.getLatestQuote(config.shortSymbol).catch(() => null),
    marketDataClient.getLatestQuote(config.monitorSymbol).catch(() => null),
  ]);

  // 2. 获取K线
  const monitorCandles = await marketDataClient
    .getCandlesticks(config.monitorSymbol, CANDLE_PERIOD, CANDLE_COUNT)
    .catch(() => null);

  if (!monitorCandles) {
    logger.warn(`未获取到 ${config.monitorSymbol} K线数据`);
    return;
  }

  // 3. 计算指标
  // ...

  // 4. 生成信号
  // ...

  // 5. 执行交易
  // ...
}

/**
 * 主循环：并发处理所有监控标的
 */
async function runOnce(context: RunOnceContext): Promise<void> {
  const { monitorContexts, marketDataClient, trader, lastState } = context;

  const currentTime = new Date();
  const canTradeNow = /* ... */;
  const isHalfDay = /* ... */;

  if (!canTradeNow) {
    return;
  }

  // 并发处理所有监控标的
  const tasks = Array.from(monitorContexts.entries()).map(
    ([monitorSymbol, monitorContext]) =>
      processMonitor(monitorSymbol, {
        monitorContext,
        marketDataClient,
        trader,
        globalState: lastState,
        marketMonitor,
        doomsdayProtection,
        unrealizedLossMonitor,
        signalProcessor,
        currentTime,
        isHalfDay,
        canTradeNow,
      }).catch((err) => {
        logger.error(`处理监控标的 ${monitorSymbol} 失败`, formatError(err));
      })
  );

  await Promise.allSettled(tasks);
}
```

**验证标准**：
- 所有监控标的并发执行
- 单个监控标的错误不影响其他监控标的
- 日志清晰区分不同监控标的的操作

#### 阶段5: 测试和验证

**任务清单**：
- [ ] 单元测试：配置解析
- [ ] 单元测试：状态管理
- [ ] 单元测试：模块隔离
- [ ] 集成测试：单标的场景（向后兼容性）
- [ ] 集成测试：双标的场景
- [ ] 集成测试：多标的场景（3+）
- [ ] 回归测试：所有现有功能
- [ ] 性能测试：并发处理性能

**测试场景**：
1. **单标的配置**（向后兼容）
   - 环境变量无索引
   - 验证系统正常运行

2. **双标的配置**
   - 配置两个监控标的
   - 验证并发执行
   - 验证数据隔离

3. **多标的配置**（3+）
   - 配置3个或更多监控标的
   - 验证性能和稳定性

4. **错误场景**
   - 单个监控标的行情失败
   - 单个监控标的K线失败
   - 部分监控标的配置错误

---

## 5. 兼容性与迁移

### 5.1 向后兼容策略

**目标**：
- 现有单标的配置无需修改即可继续运行
- 代码变更对现有功能零影响

**实现方案**：

#### 5.1.1 配置兼容

```typescript
// src/config/config.trading.ts

/**
 * 自动检测配置模式：
 * - 如果存在 MONITOR_COUNT 或 MONITOR_SYMBOL_1，使用多标的模式
 * - 否则，使用单标的模式（无索引环境变量）
 */
export const MULTI_MONITOR_TRADING_CONFIG: MultiMonitorTradingConfig = (() => {
  const monitors: MonitorConfig[] = [];

  // 优先级1: 多标的模式（MONITOR_COUNT）
  const count = getNumberConfig('MONITOR_COUNT', 0);
  if (count && count > 0) {
    for (let i = 1; i <= count; i++) {
      const config = parseMonitorConfig(i);
      if (config) monitors.push(config);
    }
  }

  // 优先级2: 单标的模式（向后兼容）
  if (monitors.length === 0) {
    const legacyConfig = parseMonitorConfig(0);  // 索引0 = 无后缀
    if (legacyConfig) {
      monitors.push(legacyConfig);
      logger.info('[配置] 检测到单标的配置（向后兼容模式）');
    }
  }

  // 优先级3: 自动发现（扫描 _1, _2, ...）
  if (monitors.length === 0) {
    for (let i = 1; i <= 10; i++) {
      const config = parseMonitorConfig(i);
      if (config) {
        monitors.push(config);
      } else {
        break;
      }
    }
    if (monitors.length > 0) {
      logger.info(`[配置] 自动发现 ${monitors.length} 个监控标的`);
    }
  }

  return {
    monitors,
    global: { /* ... */ },
  };
})();

// 导出向后兼容的 TRADING_CONFIG（单标的）
export const TRADING_CONFIG: TradingConfig =
  MULTI_MONITOR_TRADING_CONFIG.monitors[0] || ({} as TradingConfig);
```

#### 5.1.2 代码兼容

**策略**：
- 保留 `TRADING_CONFIG` 导出（指向第一个监控标的）
- 新代码使用 `MULTI_MONITOR_TRADING_CONFIG`
- 旧代码继续使用 `TRADING_CONFIG`

**示例**：
```typescript
// 旧代码（继续工作）
import { TRADING_CONFIG } from './config/config.trading.js';
const longSymbol = TRADING_CONFIG.longSymbol;  // 仍然有效

// 新代码
import { MULTI_MONITOR_TRADING_CONFIG } from './config/config.trading.js';
for (const config of MULTI_MONITOR_TRADING_CONFIG.monitors) {
  const longSymbol = config.longSymbol;
}
```

### 5.2 迁移指南

#### 5.2.1 从单标的迁移到双标的

**步骤**：
1. 复制现有配置并添加索引 `_1`
2. 添加第二个监控标的的配置（索引 `_2`）
3. 设置 `MONITOR_COUNT=2`
4. 重启程序

**示例**：
```bash
# 原配置（单标的）
MONITOR_SYMBOL=HSI.HK
LONG_SYMBOL=61604
SHORT_SYMBOL=54283
# ...

# 迁移后（双标的）
# 监控标的1
MONITOR_SYMBOL_1=HSI.HK
LONG_SYMBOL_1=61604
SHORT_SYMBOL_1=54283
# ... 其他配置

# 监控标的2
MONITOR_SYMBOL_2=02318.HK
LONG_SYMBOL_2=61234
SHORT_SYMBOL_2=54321
# ... 其他配置

# 设置监控标的数量
MONITOR_COUNT=2
```

#### 5.2.2 批量添加监控标的

**方法1：手动配置**
逐个添加 `MONITOR_SYMBOL_N`, `LONG_SYMBOL_N`, `SHORT_SYMBOL_N` 等配置

**方法2：配置生成脚本**（可选）
创建脚本自动生成配置：
```typescript
// scripts/generateMonitorConfig.ts

interface MonitorInput {
  monitor: string;
  long: string;
  short: string;
  // ... 其他必填字段
}

const monitors: MonitorInput[] = [
  { monitor: 'HSI.HK', long: '61604', short: '54283', /* ... */ },
  { monitor: '02318.HK', long: '61234', short: '54321', /* ... */ },
  // ...
];

// 生成 .env.local 配置
let output = '';
for (let i = 0; i < monitors.length; i++) {
  const m = monitors[i];
  const suffix = `_${i + 1}`;

  output += `MONITOR_SYMBOL${suffix}=${m.monitor}\n`;
  output += `LONG_SYMBOL${suffix}=${m.long}\n`;
  output += `SHORT_SYMBOL${suffix}=${m.short}\n`;
  // ... 其他配置
  output += '\n';
}

console.log(output);
```

---

## 6. 风险与注意事项

### 6.1 技术风险

#### 6.1.1 并发安全

**风险**：
- 多个监控标的同时交易同一标的时，订单可能冲突
- 账户余额检查可能不准确

**缓解措施**：
- 订单执行加锁（Trader 模块内部使用互斥锁）
- 账户余额实时查询（交易前再次确认）
- 添加订单冲突检测

**示例**：
```typescript
// src/core/trader/orderExecutor.ts

// 全局订单执行锁（确保同一时间只有一个订单在执行）
let orderExecutionLock: Promise<void> = Promise.resolve();

async function executeSignal(signal: Signal): Promise<void> {
  // 等待前一个订单执行完成
  await orderExecutionLock;

  // 创建新的执行锁
  orderExecutionLock = (async () => {
    try {
      // 实时查询账户余额
      const account = await trader.getAccountSnapshot();

      // 检查余额
      if (account.totalCash < estimatedCost) {
        logger.error('账户余额不足，跳过订单');
        return;
      }

      // 执行订单
      await actuallyExecuteOrder(signal);
    } finally {
      // 释放锁
    }
  })();

  await orderExecutionLock;
}
```

#### 6.1.2 订单记录冲突

**风险**：
- 监控标的1和监控标的2都交易同一个 `LONG_SYMBOL`
- 订单记录混淆，成本价计算错误

**缓解措施**：
- **方案1**：限制配置（不允许多个监控标的交易相同标的）
- **方案2**：订单记录按 `(monitorSymbol, tradingSymbol)` 二元组隔离

**推荐方案1**：
在配置验证时检测并拒绝重复标的：
```typescript
// src/config/config.validator.ts

function validateMonitorConfigs(configs: MonitorConfig[]): void {
  const tradingSymbols = new Set<string>();

  for (const config of configs) {
    if (tradingSymbols.has(config.longSymbol)) {
      throw new Error(`重复的交易标的: ${config.longSymbol}`);
    }
    if (tradingSymbols.has(config.shortSymbol)) {
      throw new Error(`重复的交易标的: ${config.shortSymbol}`);
    }

    tradingSymbols.add(config.longSymbol);
    tradingSymbols.add(config.shortSymbol);
  }
}
```

#### 6.1.3 内存和性能

**风险**：
- 多个监控标的导致内存占用增加
- 并发处理导致 API 调用频率过高

**缓解措施**：
- 对象池优化（已存在）
- API 频率限制（Trader 模块的 RateLimiter）
- 合理设置监控标的数量上限（建议 ≤ 10）

**监控指标**：
```typescript
// 定期记录性能指标
setInterval(() => {
  logger.debug(`[性能监控] 内存: ${process.memoryUsage().heapUsed / 1024 / 1024} MB`);
  logger.debug(`[性能监控] 对象池: Signal=${signalObjectPool.size()}, Position=${positionObjectPool.size()}`);
}, 60000);  // 每分钟
```

### 6.2 业务风险

#### 6.2.1 风险分散与集中

**风险**：
- 多个监控标的同时触发买入信号，资金快速消耗
- 单日亏损可能超过预期（多个监控标的的亏损累加）

**缓解措施**：
- 设置全局最大持仓限制（跨所有监控标的）
- 设置全局单日最大亏损限制
- 监控标的间的相关性分析（避免高度相关的标的）

**新增配置**：
```bash
# 全局风险限制（跨所有监控标的）
GLOBAL_MAX_POSITION_NOTIONAL=500000   # 全局最大持仓
GLOBAL_MAX_DAILY_LOSS=15000           # 全局单日最大亏损
```

#### 6.2.2 策略过度交易

**风险**：
- 多个监控标的频繁交易，手续费增加
- 交易频率过高可能触发券商限制

**缓解措施**：
- 合理设置 `BUY_INTERVAL_SECONDS`
- 监控每日交易次数
- 设置全局交易次数限制

### 6.3 测试风险

#### 6.3.1 回归测试覆盖

**风险**：
- 重构可能引入 bug，影响现有功能

**缓解措施**：
- 完整的回归测试
- 小规模试运行（先测试单标的，再测试多标的）
- 日志对比（新旧版本日志对比，确认行为一致）

#### 6.3.2 生产环境验证

**风险**：
- 测试环境与生产环境差异
- 模拟交易与真实交易差异

**缓解措施**：
- 灰度发布（先在小资金账户测试）
- 监控告警（异常交易行为告警）
- 回滚方案（保留旧版本代码，随时回滚）

---

## 7. 开发时间估算

### 7.1 工作量分解

| 阶段 | 任务 | 预计时间 | 风险缓冲 | 总计 |
|------|------|----------|----------|------|
| 阶段1 | 配置层重构 | 1.5天 | 0.5天 | 2天 |
| 阶段2 | 状态管理重构 | 0.5天 | 0.5天 | 1天 |
| 阶段3 | 核心模块适配 | 2.5天 | 1天 | 3.5天 |
| 阶段4 | 主循环重构 | 2天 | 1天 | 3天 |
| 阶段5 | 测试和验证 | 2天 | 1天 | 3天 |
| 文档 | 用户文档、API文档 | 0.5天 | 0.5天 | 1天 |
| **总计** | | **9天** | **4.5天** | **13.5天** |

### 7.2 里程碑

- **M1 (Day 2)**: 配置层重构完成，支持多标的配置解析
- **M2 (Day 3)**: 状态管理重构完成，新的 `LastState` 结构就绪
- **M3 (Day 7)**: 核心模块适配完成，所有模块支持多实例
- **M4 (Day 10)**: 主循环重构完成，并发处理功能就绪
- **M5 (Day 13)**: 测试完成，代码可发布
- **M6 (Day 14)**: 文档完成，正式发布

### 7.3 关键路径

```
配置层重构 → 状态管理重构 → 核心模块适配 → 主循环重构 → 测试验证
```

**并行任务**：
- 配置文档编写可与阶段1并行
- 单元测试可与各阶段开发并行

---

## 8. 总结

### 8.1 重构价值

**业务价值**：
- 支持多个监控标的，扩大交易覆盖范围
- 提高资金利用效率（多策略并行）
- 降低单一标的风险（分散投资）

**技术价值**：
- 架构更清晰，模块化程度更高
- 可扩展性大幅提升
- 并发处理能力增强

**可维护性**：
- 配置管理更规范
- 代码结构更合理
- 测试覆盖更完善

### 8.2 关键决策

1. **配置方式**：推荐索引编号方式（向后兼容，易于理解）
2. **模块隔离**：为每个监控标的创建独立实例（Strategy、OrderRecorder、RiskChecker等）
3. **并发策略**：Promise.allSettled 并发处理所有监控标的
4. **向后兼容**：完全兼容现有单标的配置，零迁移成本
5. **风险控制**：不允许多个监控标的交易相同标的（避免订单冲突）

### 8.3 后续优化方向

1. **动态配置热更新**：无需重启即可添加/删除监控标的
2. **配置 UI 界面**：通过 Web 界面管理监控标的配置
3. **策略库扩展**：支持不同监控标的使用不同策略算法
4. **性能优化**：指标计算缓存、行情数据复用
5. **监控告警**：监控标的间的相关性监控、异常交易告警

---

## 附录

### A. 配置示例

#### A.1 单标的配置（向后兼容）

```bash
# .env.local
MONITOR_SYMBOL=HSI.HK
LONG_SYMBOL=61604
SHORT_SYMBOL=54283
SIGNAL_BUYCALL=(RSI:6<25,MFI<15,D<25,J<-1)/3|(J<-20)
# ... 其他配置
```

#### A.2 双标的配置

```bash
# .env.local
MONITOR_COUNT=2

# 监控标的1
MONITOR_SYMBOL_1=HSI.HK
LONG_SYMBOL_1=61604
SHORT_SYMBOL_1=54283
SIGNAL_BUYCALL_1=(RSI:6<25,MFI<15,D<25,J<-1)/3|(J<-20)
# ...

# 监控标的2
MONITOR_SYMBOL_2=02318.HK
LONG_SYMBOL_2=61234
SHORT_SYMBOL_2=54321
SIGNAL_BUYCALL_2=(RSI:14<30,MFI<20,D<30)/2
# ...
```

### B. 类型定义完整示例

```typescript
// src/types/index.ts

export type MonitorConfig = {
  readonly monitorSymbol: string;
  readonly longSymbol: string;
  readonly shortSymbol: string;
  readonly targetNotional: number;
  readonly longLotSize: number | null;
  readonly shortLotSize: number | null;
  readonly maxPositionNotional: number;
  readonly maxDailyLoss: number;
  readonly maxUnrealizedLossPerSymbol: number;
  readonly buyIntervalSeconds: number;
  readonly verificationConfig: VerificationConfig;
  readonly signalConfig: SignalConfigSet;
};

export type GlobalConfig = {
  readonly doomsdayProtection: boolean;
  readonly debug: boolean;
};

export type MultiMonitorTradingConfig = {
  readonly monitors: ReadonlyArray<MonitorConfig>;
  readonly global: GlobalConfig;
};

export interface MonitorState {
  monitorSymbol: string;
  longSymbol: string;
  shortSymbol: string;
  longPrice: number | null;
  shortPrice: number | null;
  signal: string | null;
  pendingDelayedSignals: Signal[];
  monitorValues: MonitorValues | null;
  lastMonitorSnapshot: IndicatorSnapshot | null;
}

export interface MonitorContext {
  config: MonitorConfig;
  state: MonitorState;
  strategy: HangSengMultiIndicatorStrategy;
  orderRecorder: OrderRecorder;
  signalVerificationManager: SignalVerificationManager;
  riskChecker: RiskChecker;
}
```

### C. 参考资料

- LongPort OpenAPI 文档: https://open.longbridge.com
- TypeScript 最佳实践: https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html
- 工厂模式设计: https://refactoring.guru/design-patterns/factory-method

---

**文档结束**
