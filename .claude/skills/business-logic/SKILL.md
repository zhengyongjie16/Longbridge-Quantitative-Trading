---
name: business-logic
description: 当用户需要你检查是否符合业务需求，是否符合业务逻辑时，适用这个skill
---

# 业务逻辑完整说明

本文档详细描述港股自动化量化交易系统的核心业务逻辑，包括监控显示、交易信号、验证策略、订单记录、卖出策略和风险管控。

> **重要提示**：本文档是理解系统业务逻辑的权威参考，所有代码实现必须严格遵循本文档的规则。

---

## 目录

- [1. 监控和显示](#1-监控和显示)
- [2. 交易信号](#2-交易信号)
- [3. 买入操作的验证阶段策略](#3-买入操作的验证阶段策略)
- [4. 订单记录策略](#4-订单记录策略)
- [5. 卖出策略（智能平仓）](#5-卖出策略智能平仓)
- [6. 风险管控及策略](#6-风险管控及策略)
- [7. 修改订单](#7-修改订单)

---

## 1. 监控和显示

### 1.1 监控标的显示

**实时获取并显示以下信息**（仅在发生变化时显示）：

- 最新价
- 涨跌额
- 涨跌幅
- RSI6（6 周期相对强弱指标）
- MFI（资金流量指标）
- KDJ（K、D、J 三个值）
- MACD（DIF、DEA、MACD 三个值）

### 1.2 交易标的显示

**做多标的和做空标的**（仅在发生变化时显示）：

- 最新价
- 涨跌额
- 涨跌幅

### 1.3 交易后显示

**当有买入和卖出操作后，显示**：

- 账户信息（余额、净资产等）
- 持仓信息（数量、成本价、可用数量等）

---

## 2. 交易信号

所有信号采用 **"条件 1 或 条件 2"** 的逻辑，满足其中一个条件即触发信号。

### 2.1 买入做多标信号（BUYCALL）

**条件 1**：当监控标的的以下四个指标满足**三个以上**：

- RSI6 < 20
- MFI < 15
- KDJ.D < 20
- KDJ.J < -1

**条件 2**：

- KDJ.J < -20

**触发后**：进入 60 秒验证阶段（见第 3 节）

---

### 2.2 卖出做多标信号（SELLCALL）

**条件 1**：当监控标的的以下四个指标满足**三个以上**：

- RSI6 > 80
- MFI > 85
- KDJ.D > 79（注意：是 79，不是 80）
- KDJ.J > 100

**条件 2**：

- KDJ.J > 110

**触发后**：立即执行卖出策略（见第 5 节）

---

### 2.3 买入做空标信号（BUYPUT）

**条件 1**：当监控标的的以下四个指标满足**三个以上**：

- RSI6 > 80
- MFI > 85
- KDJ.D > 80
- KDJ.J > 100

**条件 2**：

- KDJ.J > 120

**触发后**：进入 60 秒验证阶段（见第 3 节）

---

### 2.4 卖出做空标信号（SELLPUT）

**条件 1**：当监控标的的以下四个指标满足**三个以上**：

- RSI6 < 20
- MFI < 15
- KDJ.D < 22（注意：是 22，不是 20）
- KDJ.J < 0

**条件 2**：

- KDJ.J < -15

**触发后**：立即执行卖出策略（见第 5 节）

---

## 3. 买入操作的验证阶段策略

买入信号（BUYCALL 和 BUYPUT）需要经过 **60 秒延迟验证**，确认趋势后才执行买入。

### 3.1 买入做多标的验证策略

**步骤 1：记录初始值**

- 当触发买入做多标信号时，立即记录：
  - J1 = 当前 KDJ.J 值
  - MACD1 = 当前 MACD 值

**步骤 2：等待 60 秒**

- 例如：触发信号时间为 10:30:30，需等待至 10:31:30

**步骤 3：获取验证值**

- 到达 60 秒时，获取当前指标值：
  - J2 = 当前 KDJ.J 值
  - MACD2 = 当前 MACD 值
- **获取方式**：直接从实时监控标的的值获取
- **容错机制**：若获取失败（时间戳不匹配），则获取距离当前时间最近的值，**误差允许 5 秒内**

**步骤 4：验证条件**

- **验证通过条件**：J2 > J1 **且** MACD2 > MACD1
- 验证通过后，买入做多标的一次

---

### 3.2 买入做空标的验证策略

**步骤 1：记录初始值**

- 当触发买入做空标信号时，立即记录：
  - J1 = 当前 KDJ.J 值
  - MACD1 = 当前 MACD 值

**步骤 2：等待 60 秒**

- 例如：触发信号时间为 10:30:30，需等待至 10:31:30

**步骤 3：获取验证值**

- 到达 60 秒时，获取当前指标值：
  - J2 = 当前 KDJ.J 值
  - MACD2 = 当前 MACD 值
- **获取方式**：直接从实时监控标的的值获取
- **容错机制**：若获取失败（时间戳不匹配），则获取距离当前时间最近的值，**误差允许 5 秒内**

**步骤 4：验证条件**

- **验证通过条件**：J2 < J1 **且** MACD2 < MACD1
- 验证通过后，买入做空标的一次

---

## 4. 订单记录策略

订单记录用于**智能平仓**和**浮亏监控**，需要准确记录未平仓的买入订单。

### 4.1 记录时机

**程序启动时**：获取当日做多和做空标的的历史买入且已成交订单并记录。

**注意**：做多和做空标的**分开获取**，互不影响。

---

### 4.2 过滤算法（从旧到新累积过滤）

这是本系统最复杂的算法之一，必须严格遵循以下步骤。

#### 步骤 1：获取原始数据

```
买入订单列表 = 获取当日全部买入订单（已成交）
卖出订单列表 = 获取当日全部卖出订单（已成交）
```

#### 步骤 2：过滤 M0（最新卖出后的买入订单）

```
M0 = 成交时间 > 最新卖出订单时间 的买入订单
```

如果没有卖出订单，则 M0 = 所有买入订单。

#### 步骤 3：从旧到新处理卖出订单

将卖出订单**按成交时间从旧到新排序**：D1（最旧）, D2, D3, ..., DN（最新）

对每个卖出订单 Di（从 D1 开始到 DN）：

##### 子步骤 3.1：获取候选买入订单

```
候选买入订单 = 当前未被过滤的买入订单列表
```

- 对于 D1：候选买入订单 = 所有买入订单（除去 M0）
- 对于 D2：候选买入订单 = M1（D1 过滤后的结果 + D1 到 D2 之间的买入订单）
- 对于 D3：候选买入订单 = M2（D2 过滤后的结果 + D2 到 D3 之间的买入订单）
- 以此类推...

##### 子步骤 3.2：获取时间过滤的买入订单

```
时间过滤的买入订单 = 候选买入订单中成交时间 < Di 的订单
```

##### 子步骤 3.3：判断是否全部卖出

```
Di 的成交数量 = Di.executedQuantity
时间过滤的买入订单总数量 = sum(时间过滤的买入订单.executedQuantity)

if Di 的成交数量 >= 时间过滤的买入订单总数量:
    # 全部卖出，无需记录这些订单
    从候选买入订单中移除所有成交时间 < Di 的订单
    continue  # 处理下一个卖出订单
```

##### 子步骤 3.4：按价格过滤（部分卖出）

如果未全部卖出，则按价格过滤：

```
价格过滤的买入订单 = 从时间过滤的买入订单中，过滤出：
    - 成交时间 < Di 的成交时间
    - 且 成交价格 >= Di 的成交价

Mi = 价格过滤的买入订单 + (成交时间 >= Di 且 < Di+1 的买入订单)
```

**注意**：

- 对于最后一个卖出订单 DN，`Di+1` 不存在，所以只包含价格过滤的买入订单
- Mi 会作为下一个卖出订单 Di+1 的候选买入订单

#### 步骤 4：合并最终结果

```
最终买入订单列表 = M0 + MN
```

其中 MN 是最后一个卖出订单 DN 过滤后的结果。

---

### 4.3 过滤算法示例

**假设数据**：

买入订单（按时间排序）：

```
B1: 时间=10:00, 价格=100, 数量=100
B2: 时间=10:05, 价格=102, 数量=100
B3: 时间=10:10, 价格=101, 数量=100
B4: 时间=10:20, 价格=103, 数量=100
B5: 时间=10:25, 价格=104, 数量=100
```

卖出订单（按时间排序）：

```
D1: 时间=10:08, 价格=101, 数量=150
D2: 时间=10:15, 价格=102, 数量=50
```

**过滤过程**：

1. **M0**：成交时间 > 10:15 的买入订单

   ```
   M0 = [B4, B5]
   ```

2. **处理 D1（时间=10:08, 价格=101, 数量=150）**：

   - 时间过滤的买入订单：B1, B2（成交时间 < 10:08）
   - 时间过滤的买入订单总数量：100 + 100 = 200
   - D1 的成交数量 150 < 200，未全部卖出
   - 价格过滤：保留价格 >= 101 的订单
     - B1（价格=100）被移除
     - B2（价格=102）保留
   - M1 = [B2] + [B3]（10:08 到 10:15 之间）= [B2, B3]

3. **处理 D2（时间=10:15, 价格=102, 数量=50）**：

   - 候选买入订单：M1 = [B2, B3]
   - 时间过滤的买入订单：B2, B3（成交时间 < 10:15）
   - 时间过滤的买入订单总数量：100 + 100 = 200
   - D2 的成交数量 50 < 200，未全部卖出
   - 价格过滤：保留价格 >= 102 的订单
     - B2（价格=102）保留
     - B3（价格=101）被移除
   - M2 = [B2]

4. **最终结果**：
   ```
   最终买入订单列表 = M0 + M2 = [B4, B5, B2]
   ```

---

### 4.4 代码实现位置

- **文件**：`src/core/orderRecorder.js`
- **方法**：`refreshOrders(symbol, isLongSymbol, forceRefresh = false)`
- **关键代码段**：orderRecorder.js:340-450

---

## 5. 卖出策略（智能平仓）

卖出策略分为**全仓清仓**和**智能平仓**两种模式，根据当前价格与成本价的关系决定。

### 5.1 卖出做多标的策略

**触发条件**：

- 条件 1：RSI6>80, MFI>85, KDJ.D>79, KDJ.J>100（四个指标满足三个以上）
- 条件 2：KDJ.J > 110

**卖出逻辑**：

```
当前价格 = 做多标的的最新价
持仓成本价 = 从 API 获取的持仓成本价（costPrice）

if 当前价格 > 持仓成本价:
    # 盈利状态：全仓清仓
    立即清仓所有做多标的持仓（使用 availableQuantity）
else:
    # 未盈利状态：智能平仓
    检查历史买入订单（已记录的订单）
    筛选出 买入价 < 当前价格 的订单

    if 存在符合条件的订单:
        卖出数量 = sum(这些订单的成交数量)
        以当前价卖出该数量
    else:
        不执行卖出（持有，HOLD）
```

**卖出后操作**：

- 刷新订单记录（调用 `refreshOrders(symbol, isLongSymbol, forceRefresh=true)`）
- 重新计算浮亏数据

---

### 5.2 卖出做空标的策略

**触发条件**：

- 条件 1：RSI6<20, MFI<15, KDJ.D<22, KDJ.J<0（四个指标满足三个以上）
- 条件 2：KDJ.J < -15

**卖出逻辑**：

```
当前价格 = 做空标的的最新价
持仓成本价 = 从 API 获取的持仓成本价（costPrice）

if 当前价格 < 持仓成本价:
    # 盈利状态（做空标的价格下跌为盈利）：全仓清仓
    立即清仓所有做空标的持仓（使用 availableQuantity）
else:
    # 未盈利状态：智能平仓
    检查历史买入订单（已记录的订单）
    筛选出 买入价 < 当前价格 的订单

    if 存在符合条件的订单:
        卖出数量 = sum(这些订单的成交数量)
        以当前价卖出该数量
    else:
        不执行卖出（持有，HOLD）
```

**卖出后操作**：

- 刷新订单记录（调用 `refreshOrders(symbol, isLongSymbol, forceRefresh=true)`）
- 重新计算浮亏数据

---

### 5.3 成本价计算说明

**API 返回的成本价（costPrice）**：

```
costPrice = (所有买入成交额 - 所有卖出成交额) / 当前持仓数量
```

这是平摊成本价，用于**判断是否盈利**。

**开仓成本（R1）**：

```
R1 = sum(未平仓买入订单的 price × quantity)
N1 = sum(未平仓买入订单的 quantity)
开仓均价 = R1 / N1
```

这是基于未平仓订单计算的成本，用于**浮亏监控**。

---

### 5.4 代码实现位置

- **文件**：`src/index.js`
- **方法**：信号处理部分（index.js:1329-1458）
- **辅助方法**：`orderRecorder.calculateSellQuantity(symbol, currentPrice, isLongSymbol)`

---

## 6. 风险管控及策略

### 6.1 最大持仓市值限制

**检查时机**：买入前

**检查逻辑**：

```
当前持仓市值 = 持仓数量 × 成本价（从 API 获取的 costPrice）
买入后持仓市值 = 当前持仓市值 + 本次买入金额

if 买入后持仓市值 > MAX_POSITION_VALUE:
    拦截买入（不执行）
```

**配置参数**：

- `MAX_POSITION_VALUE`：允许的最大持仓市值（HKD）

---

### 6.2 浮亏检查策略

#### 6.2.1 成本计算方式

**重要**：浮亏计算使用**开仓成本**，而非**平摊成本**。

**开仓成本计算**：

```
R1 = sum(未平仓买入订单的 price × quantity)
N1 = sum(未平仓买入订单的 quantity)
```

#### 6.2.2 程序启动时初始化

```
1. 从订单记录获取未平仓买入订单列表
2. 计算开仓成本 R1 和持仓数量 N1
3. 记录到浮亏监控缓存中
```

#### 6.2.3 实时监控浮亏

```
当前持仓市值 R2 = 当前价格 × N1
当前浮亏 X = R2 - R1
```

**更新时机**：

- 每次实时价格更新时计算
- 每次买入或卖出操作后重新计算（等待订单记录刷新完成）

#### 6.2.4 浮亏数据刷新流程

**买入/卖出操作后**：

```
1. 等待订单记录刷新完成（refreshOrders）
2. 从订单记录重新计算开仓成本 R1 和持仓数量 N1
3. 更新浮亏监控缓存
```

---

### 6.3 买入前浮亏检查

**检查时机**：买入前

**检查逻辑**：

```
从实时浮亏监控缓存获取当前浮亏 X

if X < -MAX_DAILY_LOSS:
    拦截买入（禁止开新仓）
```

**配置参数**：

- `MAX_DAILY_LOSS`：单个标的的最大浮亏限制（正数，如 3000 表示最大浮亏 -3000 HKD）

**重要提示**：

- 做多标的和做空标的**互不影响**
- 做多标的浮亏超限，只拦截做多标的买入，不影响做空标的买入
- 做空标的浮亏超限，只拦截做空标的买入，不影响做多标的买入

---

### 6.4 避难程序（保护性清仓）

**触发条件**：

```
实时浮亏 X < -MAX_UNREALIZED_LOSS_PER_SYMBOL
```

**执行操作**：

```
1. 立即执行清仓操作（全部清仓）
2. 使用市价单（MO）卖出，确保立即成交
3. 卖出后强制刷新订单记录（forceRefresh=true）
4. 重新计算浮亏数据
```

**配置参数**：

- `MAX_UNREALIZED_LOSS_PER_SYMBOL`：单个标的的避难程序触发阈值（正数，如 5000 表示浮亏达到 -5000 HKD 时触发）

**重要提示**：

- 做多标的和做空标的**互不影响**
- 市价单（MO）确保立即成交，避免价格继续下跌无法卖出

---

### 6.5 牛熊证风险检查

#### 6.5.1 程序启动时检查

```
1. 判断做多标的是否为牛证（通过 warrantQuote API 的 category 字段）
2. 判断做空标的是否为熊证（通过 warrantQuote API 的 category 字段）
3. 如果是牛证或熊证，记录回收价（callPrice 字段）
```

**牛熊证类别**：

- `category = "Bull"`：牛证（做多标的）
- `category = "Bear"`：熊证（做空标的）

#### 6.5.2 买入前距回收价检查

**牛证（做多标的）检查**：

```
当前价格 = 做多标的的最新价
回收价 = callPrice
距回收价百分比 = (当前价格 - 回收价) / 回收价 × 100%

if 距回收价百分比 < 0.5%:
    拦截买入（停止买入）
```

**熊证（做空标的）检查**：

```
当前价格 = 做空标的的最新价
回收价 = callPrice
距回收价百分比 = (当前价格 - 回收价) / 回收价 × 100%

if 距回收价百分比 > -0.5%:
    拦截买入（停止买入）
```

**风险说明**：

- 牛熊证有**强制回收机制**（Mandatory Call）
- 当标的价格触及回收价，牛熊证会被强制回收，价值归零
- 需要保持安全距离，避免强制回收风险

---

### 6.6 风险检查顺序

买入前的风险检查按以下顺序执行：

```
1. 交易时段检查（是否在交易时间）
2. 收盘前检查（收盘前15分钟禁止买入）
3. 交易频率检查（同方向60秒内不能重复买入）
4. 浮亏检查（X < -MAX_DAILY_LOSS 时拦截）
5. 牛熊证距回收价检查（距离过近时拦截）
6. 最大持仓市值检查（超过限制时拦截）
```

任何一项检查不通过，都会拦截买入。

---

### 6.7 代码实现位置

- **文件**：`src/core/risk.js`
- **类**：`RiskChecker`
- **关键方法**：
  - `checkUnrealizedLossBeforeBuy(symbol, isLongSymbol)`：买入前浮亏检查
  - `shouldExecuteProtectiveLiquidation(symbol, isLongSymbol)`：避难程序触发检查
  - `checkWarrantCallPrice(symbol, currentPrice, isLongSymbol)`：牛熊证距回收价检查
  - `refreshUnrealizedLossData(orderRecorder, symbol, isLongSymbol)`：刷新浮亏数据

---

## 7. 修改订单

### 7.1 监控和修改规则

**监控对象**：所有未成交的买入订单

**修改规则**：

```
获取标的的最新价（从实时监控获取）

if 最新价 < 委托价:
    修改委托价 = 最新价
```

**不修改情况**：

- 卖出订单：不监控，不修改
- 最新价 >= 委托价：不修改

### 7.2 监控时机

**启用监控**：

- 发起买入交易后，自动启用监控

**停止监控**：

- 所有买入订单成交后，自动停止监控

### 7.3 监控频率

- 实时监控（每次价格更新时检查）
- 仅修改价格差异 >= 0.001 的订单（避免频繁修改）

### 7.4 修改订单的原因

- **提高成交概率**：当市场价格下跌时，降低委托价以尽快成交
- **避免资金空等**：长时间未成交的订单会占用资金，降低资金使用效率

### 7.5 代码实现位置

- **文件**：`src/core/trader.js`
- **方法**：
  - `monitorAndManageOrders(longQuote, shortQuote)`：监控和管理订单
  - `replaceOrderPrice(orderId, newPrice, quantity)`：修改订单价格
  - `enableBuyOrderMonitoring()`：启用买入订单监控

---

## 8. 关键数据流

### 8.1 程序启动时

```
1. 初始化 LongBridge API 连接（Quote、Trade）
2. 订阅监控标的、做多标的、做空标的的实时行情
3. 获取并记录未平仓买入订单（做多和做空分开）
   - 调用 orderRecorder.refreshOrders()
4. 计算初始浮亏数据
   - 调用 riskChecker.refreshUnrealizedLossData()
5. 获取牛熊证信息（如果标的是牛熊证）
   - 记录回收价（callPrice）
6. 开始主循环（每秒执行一次）
```

### 8.2 主循环（每秒执行）

```
1. 获取实时行情数据（监控标的、做多标的、做空标的）
2. 计算技术指标（RSI6, MFI, KDJ, MACD）
3. 生成交易信号
   - 立即信号（卖出/平仓）
   - 延迟信号（买入/开仓）
4. 验证延迟信号（60秒后验证）
   - 检查 J2 vs J1 和 MACD2 vs MACD1
5. 处理立即信号（卖出）
   - 成本价判断
   - 智能平仓或全仓清仓
6. 处理验证通过的买入信号
   - 风险检查（按顺序执行所有检查）
   - 提交买入订单
7. 监控和修改未成交买入订单
8. 实时更新浮亏数据
9. 检查避难程序触发条件
   - 如果触发，立即执行保护性清仓
10. 显示变化的数据（监控标的指标、交易标的价格、账户持仓）
```

### 8.3 买入操作后

```
1. 提交买入订单成功
2. 启用买入订单监控
3. 等待订单成交
4. 订单成交后：
   - 本地更新订单记录（recordLocalBuy）
   - 刷新浮亏数据（refreshUnrealizedLossData）
5. 所有买入订单成交后，停止监控
```

### 8.4 卖出操作后

```
1. 提交卖出订单成功
2. 等待订单成交
3. 订单成交后：
   - 本地更新订单记录（recordLocalSell）
   - 或强制刷新订单记录（refreshOrders, forceRefresh=true）
   - 刷新浮亏数据（refreshUnrealizedLossData）
4. 显示账户和持仓信息
```

### 8.5 保护性清仓后

```
1. 触发避难程序（浮亏超过阈值）
2. 使用市价单（MO）立即清仓
3. 强制刷新订单记录（refreshOrders, forceRefresh=true）
4. 刷新浮亏数据（refreshUnrealizedLossData）
5. 记录清仓日志
```

---

## 9. 配置参数汇总

### 9.1 交易标的配置

| 参数             | 说明             | 示例                    |
| ---------------- | ---------------- | ----------------------- |
| `MONITOR_SYMBOL` | 监控标的代码     | `800000.HK`（恒生指数） |
| `LONG_SYMBOL`    | 做多标的代码     | `66666.HK`（牛证）      |
| `SHORT_SYMBOL`   | 做空标的代码     | `66700.HK`（熊证）      |
| `LONG_LOT_SIZE`  | 做多标的每手股数 | `10000`                 |
| `SHORT_LOT_SIZE` | 做空标的每手股数 | `10000`                 |

### 9.2 交易金额配置

| 参数              | 说明                    | 示例   |
| ----------------- | ----------------------- | ------ |
| `TARGET_NOTIONAL` | 每次买入目标金额（HKD） | `5000` |

### 9.3 风险控制配置

| 参数                             | 说明                          | 示例          |
| -------------------------------- | ----------------------------- | ------------- |
| `MAX_POSITION_VALUE`             | 单个标的最大持仓市值（HKD）   | `50000`       |
| `MAX_DAILY_LOSS`                 | 单个标的最大浮亏（HKD，正数） | `3000`        |
| `MAX_UNREALIZED_LOSS_PER_SYMBOL` | 避难程序触发阈值（HKD，正数） | `5000`        |
| `WARRANT_CALL_PRICE_THRESHOLD`   | 牛熊证距回收价安全百分比      | `0.5`（0.5%） |

### 9.4 技术指标阈值配置

可以在 `strategy.js` 的构造函数中自定义阈值：

```javascript
const strategy = new HangSengMultiIndicatorStrategy({
  buycall: { rsi6: 20, mfi: 15, d: 20, j: -1 },
  sellcall: { rsi6: 80, mfi: 85, d: 79, j: 100 },
  buyput: { rsi6: 80, mfi: 85, d: 80, j: 100 },
  sellput: { rsi6: 20, mfi: 15, d: 22, j: 0 },
});
```

---

## 10. 术语表

| 术语                        | 说明                                     |
| --------------------------- | ---------------------------------------- |
| **监控标的**                | 用于生成交易信号的指标标的（如恒生指数） |
| **做多标的**                | 用于做多交易的标的（通常是牛证）         |
| **做空标的**                | 用于做空交易的标的（通常是熊证）         |
| **牛证（Bull Warrant）**    | 当标的价格上涨时获利的结构化产品         |
| **熊证（Bear Warrant）**    | 当标的价格下跌时获利的结构化产品         |
| **回收价（Call Price）**    | 牛熊证的强制回收价格，触及后价值归零     |
| **成本价（Cost Price）**    | API 返回的平摊成本价，用于判断盈利       |
| **开仓成本（R1）**          | 基于未平仓订单计算的成本，用于浮亏监控   |
| **浮亏（Unrealized Loss）** | 当前持仓的未实现亏损 = R2 - R1           |
| **智能平仓**                | 仅卖出盈利部分（买入价 < 当前价）的订单  |
| **全仓清仓**                | 卖出所有持仓（当整体盈利时）             |
| **避难程序**                | 浮亏超过阈值时的紧急清仓机制             |
| **延迟验证**                | 买入信号需要等待 60 秒确认趋势后再执行   |
| **立即信号**                | 卖出信号立即执行，无需等待               |

---

## 11. 关键注意事项

### 11.1 订单记录算法的重要性

- 订单记录算法是**智能平仓**和**浮亏监控**的基础
- 必须严格按照"从旧到新累积过滤"的算法执行
- D2+ 的数量比较必须使用 `buyOrdersBeforeSell`（成交时间 < 该卖出订单时间的买入订单）

### 11.2 成本价的两种计算方式

- **API 的 costPrice**：用于判断是否盈利（全仓清仓 vs 智能平仓）
- **开仓成本 R1**：用于浮亏监控（买入前检查、避难程序）
- 两者**不可混淆**，用途不同

### 11.3 做多和做空标的的独立性

- 做多和做空标的的订单记录**完全独立**
- 做多和做空标的的浮亏监控**完全独立**
- 做多标的浮亏超限，不影响做空标的买入，反之亦然

### 11.4 牛熊证的特殊风险

- 牛熊证有**强制回收机制**，价格触及回收价会归零
- 必须在买入前检查距回收价百分比，保持安全距离
- 牛证和熊证的检查逻辑相反：
  - 牛证：距回收价百分比 < 0.5% 时停止买入
  - 熊证：距回收价百分比 > -0.5% 时停止买入

### 11.5 市价单的使用场景

- 只在避难程序（保护性清仓）中使用市价单（MO）
- 正常卖出使用增强限价单（ELO）
- 买入始终使用增强限价单（ELO）

### 11.6 卖出后的刷新策略

- 正常卖出：使用 `recordLocalSell` 本地更新
- 保护性清仓：使用 `refreshOrders(forceRefresh=true)` 强制刷新
- 卖出后必须刷新浮亏数据

---

## 12. 代码文件映射

| 业务逻辑     | 代码文件                     | 关键方法/类                                             |
| ------------ | ---------------------------- | ------------------------------------------------------- |
| 监控和显示   | `src/index.js`               | `runOnce()` 主循环                                      |
| 交易信号生成 | `src/core/strategy.js`       | `HangSengMultiIndicatorStrategy.generateCloseSignals()` |
| 买入验证策略 | `src/index.js`               | 延迟信号处理部分（index.js:1183-1327）                  |
| 订单记录策略 | `src/core/orderRecorder.js`  | `OrderRecorder.refreshOrders()`                         |
| 卖出策略     | `src/index.js`               | 立即信号处理部分（index.js:1329-1458）                  |
| 风险管控     | `src/core/risk.js`           | `RiskChecker` 类                                        |
| 修改订单     | `src/core/trader.js`         | `Trader.monitorAndManageOrders()`                       |
| 订单执行     | `src/core/trader.js`         | `Trader.executeSignals()`                               |
| 技术指标计算 | `src/services/indicators.js` | `buildIndicatorSnapshot()`                              |

---

## 版本历史

- **v1.0.0** (2024-12-20): 初始版本，完整业务逻辑说明文档
