---
name: core-program-business-logic
description: 港股量化交易系统业务逻辑及程序执行逻辑知识库。包含信号生成、买卖策略、订单记录、风险检查、浮亏监控、牛熊证风险、延迟验证等。用于理解交易逻辑、验证代码实现、修改功能、解答业务规则。涉及信号配置、成本价计算、智能平仓、保护性清仓、订单过滤算法时使用。
---

# 业务逻辑知识库

港股量化交易系统的核心业务逻辑及程序执行逻辑参考。

**核心机制**：支持多监控标的并行处理 → 监控技术指标生成信号 → 牛熊证双向交易 → 所有信号延迟验证(60秒) → 智能平仓 + 浮亏保护 + 末日保护

**架构特点**：
- 支持多个监控标的并发处理，每个监控标的有独立的配置、状态和风险检查
- 每个监控标的独立生成信号、记录订单、监控浮亏
- 全局共享订单执行器、行情客户端和末日保护模块

---

## 使用说明

### 何时使用

1. 用户询问业务逻辑（信号生成、卖出策略等）
2. 验证代码是否符合业务规则
3. 修改交易功能前了解规则
4. 调试业务问题

### 关键概念区分

| 概念对 | 区别 |
|--------|------|
| 平摊成本价 vs 开仓成本 | 前者判断盈利，后者计算浮亏 |
| 监控标的 vs 交易标的 | 前者生成信号(恒指)，后者执行交易(牛熊证) |
| 智能平仓 vs 全仓清仓 | 仅卖盈利部分 vs 全部卖出 |
| 正常卖出 vs 保护性清仓 | 前者判断成本价，后者无条件清仓 |
| 延迟信号 vs 立即信号 | 所有信号(买入和卖出)均需验证60秒 |
| ELO vs MO | 增强限价单(正常) vs 市价单(保护性清仓) |

### 核心执行顺序

- **主循环**：交易日检查 → 并发处理所有监控标的 → 全局订单监控
- **单标的处理**：行情获取 → 指标计算 → 信号生成 → 延迟验证 → 风险检查 → 订单执行
- **风险检查**：交易频率 → 买入价格限制 → 末日保护 → 牛熊证风险 → 基础风险（5项检查）
- **订单过滤**：从旧到新累积过滤，不可倒序
- **数据获取**：买入前实时获取账户/持仓，卖出可用缓存

---

## 1. 交易信号

**文件**：`src/core/strategy/index.ts`

### 1.1 信号类型

| 信号 | 动作 | 执行 |
|------|------|------|
| BUYCALL | 买入做多 | 延迟验证 |
| SELLCALL | 卖出做多 | 延迟验证 |
| BUYPUT | 买入做空 | 延迟验证 |
| SELLPUT | 卖出做空 | 延迟验证 |

### 1.2 信号配置

**格式**：`(条件1,条件2,...)/N|(条件A)|(条件B,条件C)/M`

- `/N`：需满足N项，不设则全部满足
- `|`：满足任一组即可
- **支持指标**：RSI:n、MFI、K/D/J、MACD/DIF/DEA、EMA:n
- **运算符**：`<`、`>`，支持负数如`J<-20`

**示例**：`(RSI:6<20,MFI<15,D<20,J<-1)/3|(J<-20)`
- 含义：4个条件满足3个 或 J<-20

---

## 2. 延迟验证策略

**文件**：`src/core/signalVerification/index.ts`

### 2.1 验证机制

所有信号（买入和卖出）均需延迟验证，确认趋势持续性后才执行交易。

- **延迟时间**：默认60秒，可配置0-120秒
- **验证指标**：默认D和DIF，可配置K/D/J/MACD/DIF/DEA/EMA
- **适用信号**：BUYCALL、SELLCALL、BUYPUT、SELLPUT

### 2.2 验证流程

**时间点**：
- T0 = 触发时间（信号生成时刻）
- T1 = T0 + 5秒（第一次确认点）
- T2 = T0 + 10秒（第二次确认点）

**验证窗口**：触发前5秒到后15秒内持续记录指标值，每个时间点允许±5秒误差

**验证规则**（所有验证指标在3个时间点都必须满足）：

| 信号类型 | 趋势要求 | 验证条件 |
|---------|---------|---------|
| BUYCALL | 上涨趋势 | T0、T1、T2 的值都 > 初始值 |
| BUYPUT | 下跌趋势 | T0、T1、T2 的值都 < 初始值 |
| SELLCALL | 下跌趋势 | T0、T1、T2 的值都 < 初始值 |
| SELLPUT | 上涨趋势 | T0、T1、T2 的值都 > 初始值 |

**失败处理**：任一验证指标在任一时间点不满足条件，验证失败，丢弃信号

**验证就绪**：信号触发后需等待15秒（确保T2时间点数据已记录），然后执行验证

---

## 3. 订单记录/持仓记录策略

**文件**：`src/core/orderRecorder/index.ts`

### 3.1 记录时机

- **启动时**：合并historyOrders和todayOrders，去重
- **交易后**：本地更新，不调API
- **保护性清仓后**：强制从API刷新(forceRefresh)

### 3.2 过滤算法（从旧到新累积过滤）

**核心方法**：`applyFilteringAlgorithm()`（位于`orderFilteringEngine.ts`）

**算法目标**：识别未被完全卖出的买入订单，为智能平仓和浮亏监控提供准确数据

**执行步骤**：

1. **排序卖出订单**：将所有卖出订单按成交时间从旧到新排序（D1→D2→...→DN）

2. **初始化**：
   - **M0**：成交时间 > 最新卖出订单时间的买入订单（无条件保留）
   - **candidateOrders**：成交时间 ≤ 最新卖出订单时间的买入订单（需要过滤）
   - **初始订单**：candidateOrders中成交时间 < D1时间的买入订单

3. **从旧到新处理每个卖出订单**（D1→DN，顺序不可颠倒）：
   - 对于卖出订单Di，基于上一轮结果M_{i-1}：
     - 获取M_{i-1}中成交时间 < Di时间的买入订单
     - 计算这些买入订单的总数量
     - **判断卖出类型**：
       - 若Di数量 ≥ 买入总量：全部卖出，这些订单不保留
       - 若Di数量 < 买入总量：部分卖出，保留成交价 ≥ Di成交价的订单
     - **关键**：从**原始candidateOrders**获取成交时间在 (Di, Di+1) 之间的订单（不是从M_{i-1}获取）
     - Mi = 过滤结果 + 时间间隔订单

4. **合并结果**：最终记录 = M0 + MN

**关键约束**：
- 必须按时间顺序从旧到新处理卖出订单，不可倒序或乱序
- 每轮过滤基于上一轮结果，但时间间隔订单必须从原始candidateOrders获取
- 时间间隔使用开区间 (Di, Di+1)，即 > Di时间 且 < Di+1时间

**示例**：
```
买入订单：B1(时间100,价格10,数量100) B2(时间200,价格15,数量100) B3(时间300,价格20,数量100) B4(时间400,价格25,数量100)
卖出订单：D1(时间150,价格8,数量50) D2(时间250,价格11,数量50) D3(时间350,价格18,数量50)

M0 = [B4]（时间400 > 350）
candidateOrders = [B1, B2, B3]（时间 ≤ 350）
初始订单 = [B1]（时间100 < 150）

处理D1：
  - B1数量100 > D1数量50，需过滤
  - 保留价格≥8的 → [B1]
  - 时间间隔(150,250)订单从candidateOrders获取 → [B2]
  - M1 = [B1, B2]

处理D2：
  - M1中时间<250的 = [B1,B2]，数量200
  - D2数量50 < 200，需过滤
  - 保留价格≥11的 → [B2]（B1价格10<11）
  - 时间间隔(250,350)订单从candidateOrders获取 → [B3]
  - M2 = [B2, B3]

处理D3：
  - M2中时间<350的 = [B2,B3]，数量200
  - D3数量50 < 200，需过滤
  - 保留价格≥18的 → [B3]（B2价格15<18，B3价格20≥18）
  - M3 = [B3]

最终记录 = M0 + M3 = [B4] + [B3] = [B3, B4]
```

### 3.3 本地记录

- `recordLocalBuy()` - 买入后新增
- `recordLocalSell()` - 卖出后按价格过滤
- `clearBuyOrders()` - 保护性清仓清空所有

---

## 4. 卖出策略

**文件**：`src/core/signalProcessor/index.ts`

### 4.1 判断逻辑

**核心方法**：`calculateSellQuantity()`（位于`signalProcessor/index.ts`）

**卖出信号处理流程**（在`processSellSignals`方法中）：

1. **识别末日保护清仓信号**：
   - 检查信号原因是否包含"末日保护程序"
   - 末日保护清仓：无条件执行，使用全部可用持仓数量，跳过成本价判断

2. **正常卖出信号处理**（非末日保护）：
   - 调用`calculateSellQuantity`进行成本价判断和数量计算

**成本价判断规则**（`calculateSellQuantity`方法）：

| 条件 | 操作 | 说明 |
|------|------|------|
| 当前价 > 成本价 | 全仓清仓 | 使用`availableQuantity`（全部可用持仓） |
| 当前价 ≤ 成本价 | 智能平仓 | 仅卖出buyPrice < currentPrice的历史订单 |
| 无符合条件订单 | 设为HOLD | 跳过此信号，不执行卖出 |

**智能平仓详细逻辑**（当前价 ≤ 成本价时）：
1. 调用`orderRecorder.getBuyOrdersBelowPrice(currentPrice, direction)`获取符合条件的订单
2. 计算这些订单的总数量
3. 确保卖出数量不超过可用持仓数量
4. 返回计算后的卖出数量和原因描述

**特殊情况处理**：
- 持仓或行情数据无效：返回`shouldHold=true`，跳过信号
- 无法获取订单记录器：返回`shouldHold=true`，跳过信号
- 没有符合条件的历史订单：返回`shouldHold=true`，跳过信号

### 4.2 成本价类型

| 类型 | 计算 | 用途 |
|------|------|------|
| 平摊成本价 | (买入额 - 卖出额) / 持仓量 | 判断盈利 |
| 开仓成本R1 | Σ(未平仓买入 price × qty) | 浮亏监控 |

---

## 5. 风险管控

**文件**：`src/core/risk/index.ts`

### 5.1 风险检查顺序（买入前）

**核心方法**：`applyRiskChecks()`（位于`signalProcessor/index.ts`）

**检查对象**：所有信号（买入和卖出），但买入信号需通过更严格的检查

**买入信号的5项检查**（按顺序执行，任一项失败则拒绝买入）：

1. **交易频率限制**（`trader._canTradeNow`）：
   - 检查：同方向买入间隔 ≥ 配置的`buyIntervalSeconds`（默认60秒）
   - 实现：记录每个监控标的每个方向的最后买入时间
   - 键格式：`${monitorSymbol}:${direction}`（如"700.HK:LONG"）
   - 失败：跳过此信号，记录需等待的秒数

2. **买入价格限制**（`orderRecorder.getLatestBuyOrderPrice`）：
   - 检查：当前价格 ≤ 最新买入订单价格（防止追高）
   - 实现：从订单记录器获取该标的最新买入订单的成交价
   - 对比：当前市场价格与最新买入价格
   - 失败：拒绝买入，记录价格对比信息

3. **末日保护检查**（`doomsdayProtection.shouldRejectBuy`）：
   - 检查：是否在收盘前15分钟内
   - 时间范围：正常日15:45-16:00，半日11:45-12:00
   - 全局配置：`DOOMSDAY_PROTECTION`环境变量控制
   - 失败：拒绝所有买入操作

4. **牛熊证风险检查**（`riskChecker.checkWarrantRisk`）：
   - 检查：监控标的价格距离回收价的安全距离
   - 牛证：距离百分比 > 0.5%
   - 熊证：距离百分比 < -0.5%
   - 保护：监控标的价格 < 1 时拒绝买入
   - 失败：拒绝买入，记录风险原因

5. **基础风险检查**（`riskChecker.checkBeforeOrder`）：
   - 包含两项子检查：
     - **浮亏检查**：单标的浮亏 > -MAX_DAILY_LOSS
     - **持仓市值限制**：单标的市值 ≤ MAX_POSITION_NOTIONAL
   - 数据获取：买入前实时并行获取账户信息和持仓信息
   - 失败：拒绝买入，记录具体原因

**卖出信号的检查**：
- 仅执行基础风险检查（第5项）
- 可使用缓存的账户和持仓数据
- 如果账户数据不可用，允许继续（卖出操作优先级高）

**数据获取策略**：
- 买入操作：总是实时获取最新账户和持仓数据（并行获取）
- 卖出操作：优先使用缓存，缓存不可用时才实时获取
- 无法获取账户数据时：买入被拒绝，卖出允许继续

**注意事项**：
- 交易时段检查在主循环层面进行，不在风险检查中
- 如果不在交易时段，不会进入信号处理流程
- 风险检查失败的信号会被释放回对象池

### 5.2 浮亏监控

**计算**：浮亏 = R2 - R1
- R1：未平仓买入订单市值总和
- R2：当前价 × 持仓量

**更新**：启动时、交易后、价格变化时

### 5.3 保护性清仓

**文件**：`src/core/unrealizedLossMonitor/index.ts`

**触发条件**：浮亏 < -MAX_UNREALIZED_LOSS_PER_SYMBOL

**执行流程**（无条件清仓，不受成本价判断影响）：
1. 创建市价单(MO)清仓信号
2. 执行清仓订单
3. 清空订单记录（clearBuyOrders，清空所有买入订单记录）
4. 重新计算浮亏数据（订单记录已清空，浮亏数据变为空，R1=0, N1=0）

**与正常卖出的区别**：
- 正常卖出：使用ELO限价单，判断成本价，可能部分卖出
- 保护性清仓：使用MO市价单，无条件全部卖出，清空所有订单记录

### 5.4 牛熊证风险

**核心方法**：`checkWarrantRecallPrice()`

**公式**：距离% = (监控标的价 - 回收价) / 回收价 × 100%

| 类型 | 检查条件 |
|------|----------|
| 牛证 | 距离% < 0.5% 拒绝 |
| 熊证 | 距离% > -0.5% 拒绝 |

**保护**：监控标的价 < 1 时拒绝（防错误价格）

### 5.5 末日保护

**文件**：`src/core/doomsdayProtection/index.ts`

**时间规则**：

| 交易日类型 | 拒绝买入时段 | 自动清仓时段 |
|-----------|-------------|-------------|
| 正常交易日 | 15:45-16:00 | 15:55-15:59 |
| 半日交易日 | 11:45-12:00 | 11:55-11:59 |

**执行逻辑**：
- **收盘前15分钟**：拒绝所有买入操作（BUYCALL和BUYPUT）
- **收盘前5分钟**：自动生成清仓信号，使用市价单(MO)清空所有持仓
- **清仓特性**：无条件执行，不受成本价判断影响

---

## 6. 订单管理

**文件**：`src/core/trader/index.ts`

### 6.1 未成交订单监控

**核心方法**：`monitorAndManageOrders()`

**监控对象**：仅监控未成交的买入订单（BUYCALL和BUYPUT），卖出订单不监控

**监控机制**：
- 实时获取未成交订单列表
- 对比当前市场价格与委托价格
- 当前价格低于委托价格时自动降低委托价

**调整条件**（所有条件必须同时满足）：
- 当前价格 < 委托价格（价格下跌）
- 价格差异 ≥ 0.001 港币（避免频繁修改）
- 订单状态为未成交或部分成交（不包括已撤销、已成交、正在修改中的订单）

**调整操作**：
- 使用`replaceOrder` API修改订单价格
- 新价格 = 当前市场价格
- 数量保持不变（使用剩余未成交数量）

**缓存策略**：
- 未成交订单缓存15秒TTL
- 避免频繁调用API
- 订单修改后立即清空缓存

**启用时机**：
- 程序启动时检查是否有未成交买入订单
- 有未成交订单时自动启用监控
- 买入订单提交后启用监控
- 所有买入订单成交后自动停止监控

### 6.2 Trade API频率限制

**文件**：`src/services/tradeClient/index.ts`

- 30秒内≤30次
- 调用间隔≥0.02秒
- 超限自动等待

### 6.3 订单记录缓存

- **缓存时效**：永久（运行期间）
- **刷新时机**：启动时、保护性清仓后强制刷新，正常交易本地更新
- **禁用标的**：订单获取失败时禁用该标的交易

---

## 7. 关键数据流

### 7.1 程序启动

1. 验证配置，获取标的信息（支持多监控标的配置）
2. 初始化全局模块：交易器、市场监控、末日保护、浮亏监控、信号处理器
3. 为每个监控标的创建独立上下文：策略、订单记录器、信号验证管理器、风险检查器
4. 初始化每个监控标的的牛熊证信息（获取回收价）
5. 获取账户和持仓信息（全局共享）
6. 为每个监控标的初始化订单记录（从API获取并过滤）
7. 为每个监控标的初始化浮亏监控数据（R1, N1）
8. 检查是否有未成交买入订单，如有则启用订单监控
9. 启动主循环

### 7.2 主循环（每秒）

**文件**：`src/index.ts` - `runOnce()`

**全局层面执行顺序**（固定流程，不可调整）：

1. **交易日检查**：
   - 检查是否为交易日（首次或跨天时调用API，之后使用缓存）
   - 判断是否为半日交易日
   - 使用日期字符串作为缓存键，跨天时自动刷新

2. **交易时段检查**：
   - 判断是否在连续交易时段（使用`isInContinuousHKSession`）
   - 不在交易时段则跳过后续流程
   - 避免在竞价时段或非交易时段执行交易

3. **末日保护检查**（全局性，在所有监控标的处理之前）：
   - 检查是否进入收盘前5分钟（正常日15:55-15:59，半日11:55-11:59）
   - 如果是，为所有监控标的生成清仓信号
   - 执行清仓，清空所有监控标的的订单记录
   - 跳过本次循环的监控标的处理

4. **并发处理所有监控标的**（`processMonitor`函数）：
   - 每个监控标的独立执行以下流程（并发执行，互不干扰）
   - 使用`Promise.all`并行处理所有监控标的

5. **全局订单监控**（在所有监控标的处理完成后）：
   - 监控所有交易标的的未成交买入订单
   - 自动调整订单价格（价格下跌时降低委托价）

**单监控标的处理流程**（`processMonitor`函数，并发执行）：

1. **行情获取**：
   - 并行获取做多、做空、监控标的的最新行情（使用`Promise.all`）
   - 获取标的的中文名称

2. **价格监控**：
   - 检测价格变化并显示（`marketMonitor.monitorPriceChanges`）
   - 记录价格变化状态

3. **浮亏检查**（仅在价格变化时）：
   - 检查是否触发保护性清仓（`unrealizedLossMonitor.monitorUnrealizedLoss`）
   - 浮亏超限时立即执行市价单清仓

4. **K线获取**：
   - 获取监控标的的K线数据（200根1分钟K线）
   - 验证K线数据有效性

5. **指标计算**：
   - 计算RSI、MFI、KDJ、MACD、EMA等技术指标（`buildIndicatorSnapshot`）
   - 使用配置中指定的RSI周期和EMA周期

6. **指标监控**：
   - 检测指标变化并显示（`marketMonitor.monitorIndicatorChanges`）
   - 释放上一次快照中的对象（KDJ、MACD）

7. **持仓获取**：
   - 从全局缓存的持仓列表中提取该监控标的的做多和做空持仓
   - 使用对象池管理持仓对象

8. **信号生成**：
   - 根据配置条件生成交易信号（`strategy.generateCloseSignals`）
   - 返回立即信号和延迟信号

9. **延迟信号管理**：
   - 添加新延迟信号到待验证列表（`signalVerificationManager.addDelayedSignals`）
   - 记录当前指标值到验证历史（`recordVerificationHistory`）
   - 验证延迟信号（检查3个时间点的趋势，`verifyPendingSignals`）

10. **信号验证和过滤**：
    - 合并立即信号和已验证信号
    - 过滤无效信号（检查symbol、action等字段）
    - 释放无效信号对象回对象池

11. **信号变化检测**：
    - 对比当前信号与上次信号
    - 信号变化时记录日志

12. **补充信号信息**：
    - 为信号补充价格、lotSize、symbolName等信息
    - 从对应的行情数据中获取

13. **风险检查**（仅在交易时段内）：
    - 对所有信号执行风险检查（`signalProcessor.applyRiskChecks`）
    - 买入信号执行5项检查，卖出信号执行基础检查
    - 释放被拒绝的信号对象

14. **卖出信号处理**：
    - 成本价判断（`signalProcessor.processSellSignals`）
    - 计算卖出数量（全仓/智能平仓/HOLD）
    - 末日保护清仓信号无条件执行

15. **订单执行**：
    - 过滤掉被设为HOLD的信号
    - 提交交易订单（`trader.executeSignals`）
    - 启用买入订单监控（如果有买入操作）

16. **交易后处理**（仅该监控标的）：
    - 本地更新订单记录（`orderRecorder.recordLocalBuy/recordLocalSell`）
    - 刷新浮亏数据（`riskChecker.refreshUnrealizedLossData`）
    - 显示账户信息（卖出后）
    - 释放信号和持仓对象回对象池

**关键特性**：
- 所有监控标的并发处理，互不阻塞
- 每个监控标的有独立的状态、配置和风险检查
- 全局共享订单执行器、行情客户端、末日保护模块
- 使用对象池管理内存，减少GC压力

### 7.3 交易后

**买入**：本地记录→刷新浮亏→启用监控
**卖出**：本地记录→刷新浮亏→显示账户→记录日志
**保护性清仓**：市价单→强制刷新订单→刷新浮亏→记录日志

---

## 8. 配置

**文件**：`src/config/*.ts`、`.env.local`

### 8.1 必需配置

**多标的支持**：系统支持多个监控标的，通过`MONITOR_COUNT`指定数量，每个监控标的使用后缀`_N`（N从1开始）区分。

**全局配置**：
| 配置 | 说明 | 默认 |
|------|------|------|
| MONITOR_COUNT | 监控标的数量（必须≥1） | - |

**单监控标的配置**（每个监控标的独立配置，使用后缀`_N`，如`_1`、`_2`）：
| 配置 | 说明 |
|------|------|
| MONITOR_SYMBOL_N | 监控标的（恒指等） |
| LONG_SYMBOL_N | 做多标的（牛证） |
| SHORT_SYMBOL_N | 做空标的（熊证） |
| LONG_LOT_SIZE_N | 做多每手股数 |
| SHORT_LOT_SIZE_N | 做空每手股数 |
| TARGET_NOTIONAL_N | 每次买入金额 |
| SIGNAL_BUYCALL_N/SELLCALL_N/BUYPUT_N/SELLPUT_N | 信号配置 |

**示例**：配置两个监控标的时，使用`MONITOR_SYMBOL_1`、`LONG_SYMBOL_1`等配置第一个，使用`MONITOR_SYMBOL_2`、`LONG_SYMBOL_2`等配置第二个。

### 8.2 风险配置

| 配置 | 说明 | 默认 |
|------|------|------|
| MAX_POSITION_NOTIONAL | 最大持仓市值 | - |
| MAX_DAILY_LOSS | 最大浮亏 | - |
| MAX_UNREALIZED_LOSS_PER_SYMBOL | 保护性清仓阈值 | 0 |
| DOOMSDAY_PROTECTION | 末日保护 | true |
| BUY_INTERVAL_SECONDS | 买入间隔 | 60 |

### 8.3 验证配置（每个监控标的独立配置）

| 配置 | 说明 | 默认 |
|------|------|------|
| VERIFICATION_DELAY_SECONDS_BUY_N | 买入延迟时间(0-120秒) | 60 |
| VERIFICATION_DELAY_SECONDS_SELL_N | 卖出延迟时间(0-120秒) | 60 |
| VERIFICATION_INDICATORS_BUY_N | 买入验证指标（K/D/J/MACD/DIF/DEA/EMA:n） | D,DIF |
| VERIFICATION_INDICATORS_SELL_N | 卖出验证指标（K/D/J/MACD/DIF/DEA/EMA:n） | D,DIF |

**注意**：买入和卖出可以配置不同的延迟时间和验证指标。

---

## 9. 术语表

| 术语 | 说明 |
|------|------|
| 监控标的 | 生成信号的标的（恒指） |
| 做多/做空标的 | 交易标的（牛/熊证） |
| 牛/熊证 | 标的涨/跌盈利的产品 |
| 回收价 | 牛熊证强制回收价 |
| 成本价 | 平摊成本，判断盈利 |
| 开仓成本R1 | 未平仓订单成本，浮亏监控 |
| 持仓量N1 | 未平仓订单总量 |
| 浮亏 | R2 - R1 |
| 智能平仓 | 仅卖盈利部分 |
| 全仓清仓 | 卖出全部 |
| 保护性清仓 | 浮亏超限紧急清仓 |
| ELO | 增强限价单 |
| MO | 市价单 |

---

## 10. 关键注意事项

### 10.1 成本价区分

- **平摊成本价**：判断盈利→全仓/智能平仓
- **开仓成本R1**：浮亏监控→保护性清仓

### 10.2 做多做空独立

- 订单记录独立（做多和做空分别记录）
- 浮亏监控独立（各自R1, N1）
- 一方浮亏不影响另一方

### 10.12 多监控标的独立性

- **配置独立**：每个监控标的有独立的信号配置、风险配置、验证配置（使用后缀`_N`区分）
- **状态独立**：每个监控标的有独立的监控状态（价格、指标、待验证信号列表）
- **订单记录独立**：每个监控标的有独立的订单记录器实例（但共享订单API缓存以避免重复调用）
- **风险检查独立**：每个监控标的有独立的风险检查器实例（使用各自的配置参数）
- **信号验证独立**：每个监控标的有独立的信号验证管理器（使用各自的验证配置和待验证信号列表）
- **浮亏监控独立**：每个监控标的独立监控各自的做多和做空标的浮亏（独立的R1、N1数据）
- **并发处理**：所有监控标的在主循环中并发处理（使用`Promise.all`），互不干扰
- **全局共享**：订单执行器、行情客户端、末日保护模块全局共享（所有监控标的共用）
- **交易频率限制**：每个监控标的的每个方向独立记录最后买入时间（键格式：`${monitorSymbol}:${direction}`）

### 10.3 牛熊证风险

- 使用**监控标的价格**计算距回收价%（非牛熊证价格）
- 牛证和熊证检查方向相反
- 监控标的价 < 1 时拒绝买入

### 10.4 订单过滤算法

- 智能平仓和浮亏监控的基础
- 必须"从旧到新累积过滤"（按卖出订单时间顺序处理）
- 每轮过滤基于上一轮结果继续过滤
- **关键**：时间间隔订单必须从原始candidateOrders获取（不是从上一轮结果获取）
- 时间间隔使用开区间 (Di, Di+1)，即 > Di时间 且 < Di+1时间
- 算法实现在独立的`orderFilteringEngine.ts`模块中（纯函数，无状态）

### 10.5 市价单使用

- 仅保护性清仓使用MO
- 正常交易使用ELO

### 10.6 刷新策略

- 正常卖出：本地更新
- 保护性清仓：强制API刷新
- 卖出后必须刷新浮亏

### 10.7 买入数据获取

- 买入前：实时获取账户/持仓（并行获取，使用`Promise.all`）
- 卖出时：优先使用缓存，缓存不可用时才实时获取
- 无法获取账户时：买入被拒绝，卖出允许继续
- 数据获取在`applyRiskChecks`方法中执行

### 10.8 末日/浮亏保护清仓

- 末日保护清仓：无条件执行，不受成本价判断影响
- 浮亏保护清仓：无条件执行，使用市价单(MO)
- 两种清仓都会清空所有订单记录（使用`clearBuyOrders`）
- 清仓后立即刷新浮亏数据（R1=0, N1=0）

### 10.9 延迟验证3点确认

**验证时间点**：T0（触发时间）、T0+5s、T0+10s

**验证要求**：所有验证指标在所有3个时间点都必须满足趋势条件

**趋势方向**：
- BUYCALL（买入做多）：3点都 > 初始值（上涨趋势）
- BUYPUT（买入做空）：3点都 < 初始值（下跌趋势）
- SELLCALL（卖出做多）：3点都 < 初始值（下跌趋势）
- SELLPUT（卖出做空）：3点都 > 初始值（上涨趋势）

**失败条件**：任一验证指标在任一时间点不满足条件，验证失败，丢弃信号

**验证窗口**：触发前5秒到后15秒内持续记录指标值，确保能捕获所有时间点数据

### 10.10 订单双API机制

- 启动时同时调用historyOrders和todayOrders
- 合并去重（基于orderId）
- 防止historyOrders遗漏今日订单

### 10.11 技术约束

- 标的代码：`normalizeHKSymbol()` 规范化，带`.HK`后缀
- Decimal转换：`decimalToNumber()` 转换LongPort SDK的Decimal类型
- 订单类型：ELO（正常交易）、MO（保护性清仓）
- 数据获取：买入前实时获取账户/持仓，卖出可用缓存
- 订单缓存：永久缓存（程序运行期间），启动时和保护性清仓后刷新
- 交易日缓存：跨天或首次运行时获取，之后使用缓存
- 对象池：Signal、Position、KDJ、MACD等对象使用对象池管理，减少GC

### 10.13 交易日信息缓存

- 程序启动时调用API获取交易日信息（是否为交易日、是否为半日交易日）
- 使用日期字符串作为缓存键，跨天时自动刷新
- 缓存信息用于判断是否执行交易逻辑，避免频繁调用API

---

## 11. 核心文件

| 模块 | 文件 | 职责 |
|------|------|------|
| 主循环 | `src/index.ts` | runOnce()协调，并发处理多个监控标的 |
| 信号生成 | `src/core/strategy/index.ts` | 生成信号（每个监控标的独立） |
| 信号验证 | `src/core/signalVerification/index.ts` | 延迟验证（每个监控标的独立） |
| 信号处理 | `src/core/signalProcessor/index.ts` | 卖出数量计算、风险检查应用 |
| 订单执行 | `src/core/trader/index.ts` | 下单监控（全局共享，门面模式） |
| 订单监控 | `src/core/trader/orderMonitor.ts` | 未成交订单监控和价格调整 |
| 订单执行器 | `src/core/trader/orderExecutor.ts` | 订单提交和交易频率限制 |
| 风险检查 | `src/core/risk/index.ts` | 风险门控（每个监控标的独立，门面模式） |
| 订单记录 | `src/core/orderRecorder/index.ts` | 订单记录管理（每个监控标的独立，门面模式） |
| 订单过滤 | `src/core/orderRecorder/orderFilteringEngine.ts` | 过滤算法实现（纯函数） |
| 浮亏监控 | `src/core/unrealizedLossMonitor/index.ts` | 保护清仓（每个监控标的独立） |
| 末日保护 | `src/core/doomsdayProtection/index.ts` | 收盘保护（全局共享） |
| 市场监控 | `src/core/marketMonitor/index.ts` | 价格指标监控（全局共享） |
| 技术指标 | `src/services/indicators/index.ts` | RSI/KDJ/MACD/EMA/MFI计算 |
| 工具函数 | `src/utils/helpers/index.ts` | 规范化/转换/验证 |
| 配置解析 | `src/utils/signalConfigParser/index.ts` | 解析信号配置 |
| 交易配置 | `src/config/config.trading.ts` | 多监控标的配置解析 |
