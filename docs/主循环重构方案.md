# 主循环重构方案

> 将主循环职责精简为数据生产 + 实时保护，常规交易逻辑分离为独立的异步处理模块

## 一、重构目标

### 1.1 当前问题

当前主循环 (`runOnce` + `processMonitor`) 承担了过多职责，包括：

- 行情获取与显示
- K线获取与指标计算
- 信号生成
- 延迟验证历史记录与验证
- 浮亏检查与保护性清仓
- 风险检查
- 订单执行
- 末日保护

这导致以下问题：

1. **阻塞风险**：常规交易的 API 调用可能阻塞行情监控
2. **职责混乱**：数据生产和交易执行混在一起，难以维护
3. **扩展困难**：添加新功能需要修改主循环核心代码

### 1.2 重构目标

**主循环负责**（数据生产层 + 实时保护层）：
- 实时行情获取与显示
- K线数据获取
- 技术指标计算与缓存
- 信号生成
- 指标变化监控显示
- **浮亏检测与保护性清仓**（实时性要求高，必须同步执行）
- **末日保护**（时间敏感，必须同步执行）

**分离出去的逻辑**（交易处理层）：
- 延迟验证（自行计时，仅延迟信号需要）
- 立即信号直接处理（无需延迟验证）
- 风险检查
- 卖出数量计算
- 订单执行
- 订单监控

> **设计原则**：保护性操作（浮亏清仓、末日保护）保留在主循环同步执行，确保实时响应；常规交易信号异步处理，避免阻塞主循环。

### 1.3 信号类型说明

根据验证配置，信号分为两种类型：

| 信号类型 | 产生条件 | 处理方式 |
|---------|---------|---------|
| **延迟信号** | `delaySeconds > 0` 且 `indicators` 非空 | 推入延迟验证器，等待验证后再执行 |
| **立即信号** | `delaySeconds = 0` 或 `indicators` 为空 | 直接推入任务队列，立即执行 |

> **注意**：买入和卖出可以独立配置延迟验证参数，因此可能出现买入信号需要延迟验证而卖出信号立即执行的情况。

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          主循环 (每秒执行)                               │
│                   【数据生产层 + 实时保护层 - 同步】                      │
├─────────────────────────────────────────────────────────────────────────┤
│  1. 交易日/时段检查                                                      │
│  2. 末日保护检测 → 触发时直接执行撤单/清仓（同步，确保时效）               │
│  3. 批量获取行情 → 显示价格变化                                          │
│  4. 浮亏检测 → 超限时直接执行保护性清仓（同步，确保实时）                  │
│  5. 获取K线数据                                                          │
│  6. 计算技术指标 → 存入指标缓存                                          │
│  7. 显示指标变化                                                         │
│  8. 生成交易信号 → 根据验证配置分流：                                     │
│     • 延迟信号（配置了延迟验证）→ 推入延迟验证器                          │
│     • 立即信号（未配置延迟验证）→ 直接推入任务队列                         │
└──────────────────────────────┬──────────────────────────────────────────┘
                               │
              ┌────────────────┼────────────────┐
              ▼                ▼                ▼
┌─────────────────────┐ ┌─────────────────┐ ┌─────────────────────────────┐
│     指标缓存        │ │    任务队列      │ │     延迟验证器               │
│  (IndicatorCache)   │ │  (TaskQueue)    │ │  (DelayedSignalVerifier)    │
├─────────────────────┤ ├─────────────────┤ ├─────────────────────────────┤
│ • 环形缓冲区        │ │ • FIFO 顺序     │ │ • setTimeout 自行计时        │
│ • 按标的分组        │ │ • 处理常规      │ │ • 从指标缓存读取数据         │
│ • 动态容量配置      │ │   交易信号      │ │ • 验证通过 → 推入任务队列     │
│   (delaySeconds +   │ │ • 含立即信号    │ │ • 验证失败 → 释放信号对象     │
│    windowEndOffset) │ │   和已验证信号  │ │                             │
└─────────────────────┘ └────────┬────────┘ └─────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                       交易处理器 (TradeProcessor)                        │
│                        【交易处理层 - 异步】                             │
├─────────────────────────────────────────────────────────────────────────┤
│  • 消费任务队列（立即信号 + 已验证的延迟信号）                             │
│  • 执行风险检查（API 调用获取账户/持仓）                                   │
│  • 计算卖出数量（成本价判断、智能平仓）                                    │
│  • 提交订单（API 调用）                                                  │
└─────────────────────────────────────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      WebSocket 推送处理 (已有)                           │
├─────────────────────────────────────────────────────────────────────────┤
│  • 订单状态变化 → 更新本地记录                                            │
│  • 触发缓存刷新标记                                                      │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 数据流设计

```
                              ┌──────────────────────────────────────────┐
                              │           主循环（同步执行）              │
                              ├──────────────────────────────────────────┤
浮亏超限 ────────────────────→│  保护性清仓（直接执行，确保实时）        │
末日保护触发 ────────────────→│  撤单/清仓（直接执行，确保时效）         │
                              └──────────────────────────────────────────┘

                              ┌──────────────────────────────────────────┐
                              │         异步交易处理（常规信号）          │
                              └──────────────────────────────────────────┘

                                     ┌─────────────────────────────────────┐
                                     │       信号分流（根据验证配置）       │
                                     └───────────────┬─────────────────────┘
                                                     │
                    ┌────────────────────────────────┴────────────────────────────────┐
                    │                                                                 │
                    ▼                                                                 ▼
    ┌───────────────────────────────────┐                         ┌───────────────────────────────────┐
    │  立即信号（未配置延迟验证）        │                         │  延迟信号（配置了延迟验证）        │
    │  delaySeconds=0 或 indicators=[]  │                         │  delaySeconds>0 且 indicators非空  │
    └─────────────────┬─────────────────┘                         └─────────────────┬─────────────────┘
                      │                                                             │
                      │                                                             ▼
                      │                                           ┌─────────────────────────────────────┐
                      │                                           │  延迟验证器 (setTimeout 计时)       │
                      │                                           │  • triggerTime 到达后执行验证       │
                      │                                           │  • 从指标缓存读取 T0,T1,T2 数据     │
                      │                                           └─────────────────┬─────────────────┘
                      │                                                             │
                      │                              ┌──────────────────────────────┴──────────────────────────────┐
                      │                              │                                                             │
                      │                              ▼                                                             ▼
                      │                    ┌─────────────────────┐                               ┌─────────────────────────────┐
                      │                    │    验证通过         │                               │    验证失败                 │
                      │                    └──────────┬──────────┘                               │    释放信号对象             │
                      │                               │                                          └─────────────────────────────┘
                      │                               │
                      ▼                               ▼
                    ┌─────────────────────────────────────────────────────────────────────┐
                    │                         任务队列 (FIFO)                             │
                    └───────────────────────────────────┬─────────────────────────────────┘
                                                        │
                                                        ▼
                    ┌─────────────────────────────────────────────────────────────────────┐
                    │                    交易处理器 → 订单执行                            │
                    └─────────────────────────────────────────────────────────────────────┘
```

### 2.3 模块职责划分

| 模块 | 层级 | 职责 | 执行方式 |
|------|------|------|----------|
| 主循环 | 数据生产层 + 实时保护层 | 行情/K线/指标/信号生成/信号分流/浮亏保护/末日保护 | 同步，每秒执行 |
| 指标缓存 | 数据生产层 | 存储历史指标值（供延迟验证使用） | 被动写入 |
| 延迟验证器 | 桥接层 | 延迟信号的定时验证 | setTimeout 异步 |
| 任务队列 | 桥接层 | 常规交易任务缓冲（立即信号 + 已验证信号） | 被动存取，FIFO |
| 交易处理器 | 交易处理层 | 风险检查/订单执行 | setImmediate 异步 |

### 2.4 目录结构设计

新增模块放置在 `src/program/` 目录下，与现有 `src/core/` 分离：

```
src/
├── index.ts              # 程序主入口
├── program/              # 【新增】程序运行时架构
│   ├── indicatorCache/   #   指标缓存（运行时基础设施）
│   ├── tradeTaskQueue/   #   任务队列（运行时基础设施）
│   ├── delayedSignalVerifier/  #   延迟验证器（运行时协调）
│   └── tradeProcessor/   #   交易处理器（运行时协调）
├── core/                 # 核心业务逻辑（保持不变）
│   ├── strategy/         #   信号生成策略
│   ├── signalProcessor/  #   信号处理
│   ├── trader/           #   订单执行
│   └── ...
├── services/             # 外部服务
└── utils/                # 工具函数
```

**设计原则**：

| 目录 | 职责 | 特点 |
|------|------|------|
| `src/core/` | 核心业务逻辑 | 可独立使用的业务组件，关注"做什么" |
| `src/program/` | 程序运行时架构 | 为主循环服务的运行时基础设施，关注"怎么调度" |
| `src/services/` | 外部服务 | 与外部 API 交互（行情、订单） |
| `src/utils/` | 工具函数 | 通用工具，无业务逻辑 |

### 2.5 同步 vs 异步的设计决策

| 操作类型 | 执行方式 | 原因 |
|---------|---------|------|
| 浮亏保护清仓 | **同步** | 浮亏超限需立即止损，延迟可能导致更大损失 |
| 末日保护 | **同步** | 收盘前操作有严格时间窗口，不能有任何延迟 |
| 常规交易信号 | **异步** | 经过延迟验证，不需要立即执行，可容忍队列处理延迟 |

---

## 三、核心模块设计

### 3.1 指标缓存模块 (IndicatorCache)

#### 3.1.1 设计目标

- 存储每秒的指标快照，供延迟验证器查询
- 使用环形缓冲区，自动管理内存
- 按监控标的分组存储
- **动态容量**：根据配置的延迟验证时间自动计算
- **按需提取**：只存储该监控标的配置中需要验证的指标（内存优化）

#### 3.1.2 缓存容量计算

**容量公式**：
```
maxEntries = max(buyDelaySeconds, sellDelaySeconds) + WINDOW_END_OFFSET_SECONDS + buffer
```

**参数说明**：
- `buyDelaySeconds`：买入信号延迟验证时间（配置值，默认 60 秒）
- `sellDelaySeconds`：卖出信号延迟验证时间（配置值，默认 60 秒）
- `WINDOW_END_OFFSET_SECONDS`：验证窗口结束偏移量（常量，15 秒）
- `buffer`：缓冲余量（建议 10 秒）

**示例计算**：
- 配置 `buyDelaySeconds = 60, sellDelaySeconds = 30`
- `maxEntries = max(60, 30) + 15 + 10 = 85 秒`
- 若配置 `buyDelaySeconds = 120, sellDelaySeconds = 60`
- `maxEntries = max(120, 60) + 15 + 10 = 145 秒`

**时间线示意**（以 delaySeconds = 60 为例）：
```
信号生成时刻    记录窗口开始      triggerTime(T0)       T0+10s    T0+15s
    ↓               ↓                 ↓                  ↓         ↓
    0s ----------> 55s ------------> 60s --> 65s -----> 70s ----> 75s
    │               │      指标记录窗口(T0-5s到T0+15s)    │         │
    │               └─────────────────────────────────────┘         │
    │                                                               │
    └───────────────────── 需要保存的指标历史 ───────────────────────┘
                        (至少 75 秒 = 60 + 15)
```

#### 3.1.3 接口定义

```typescript
/**
 * 指标缓存条目
 */
interface IndicatorCacheEntry {
  /** 时间戳（毫秒） */
  timestamp: number;
  /** 需要验证的指标值（只存储配置中指定的指标） */
  indicators: Record<string, number>;
}

/**
 * 监控标的的指标缓存配置
 */
interface MonitorIndicatorCacheConfig {
  /** 最大条目数（动态计算：maxDelaySeconds + windowEndOffset + buffer） */
  maxEntries: number;
  /** 需要缓存的指标列表（从买入和卖出验证配置中提取，去重后的并集） */
  indicatorsToCache: string[];
}

/**
 * 指标缓存配置
 */
interface IndicatorCacheConfig {
  /** 按监控标的分组的配置 */
  monitorConfigs: Map<string, MonitorIndicatorCacheConfig>;
}

/**
 * 指标缓存接口
 */
interface IndicatorCache {
  /**
   * 添加新的指标快照
   * @param monitorSymbol 监控标的代码
   * @param snapshot 指标快照
   */
  push(monitorSymbol: string, snapshot: IndicatorSnapshot): void;

  /**
   * 获取指定时间点附近的指标值
   * @param monitorSymbol 监控标的代码
   * @param targetTime 目标时间戳（毫秒）
   * @param toleranceMs 允许的时间误差（毫秒）
   * @returns 匹配的缓存条目，未找到返回 null
   */
  getAt(
    monitorSymbol: string,
    targetTime: number,
    toleranceMs: number,
  ): IndicatorCacheEntry | null;

  /**
   * 获取最新的指标值
   * @param monitorSymbol 监控标的代码
   */
  getLatest(monitorSymbol: string): IndicatorCacheEntry | null;

  /**
   * 获取指定时间范围内的所有条目
   * @param monitorSymbol 监控标的代码
   * @param startTime 开始时间戳
   * @param endTime 结束时间戳
   */
  getRange(
    monitorSymbol: string,
    startTime: number,
    endTime: number,
  ): IndicatorCacheEntry[];

  /**
   * 清空指定标的的缓存
   */
  clear(monitorSymbol: string): void;

  /**
   * 清空所有缓存
   */
  clearAll(): void;
}
```

#### 3.1.4 实现要点（按需提取优化 + 对象池复用）

```typescript
import { getIndicatorValue } from '../../utils/helpers/indicatorHelpers.js';
import { indicatorRecordPool } from '../../utils/objectPool/index.js';

/**
 * 创建指标缓存
 * @param config 缓存配置（包含每个监控标的需要缓存的指标列表）
 */
function createIndicatorCache(config: IndicatorCacheConfig): IndicatorCache {
  // 内部使用 Map<string, IndicatorCacheEntry[]> 存储
  // 每个数组作为环形缓冲区使用
  const cacheMap = new Map<string, IndicatorCacheEntry[]>();
  const writeIndexMap = new Map<string, number>();

  return {
    push(monitorSymbol: string, snapshot: IndicatorSnapshot): void {
      const monitorConfig = config.monitorConfigs.get(monitorSymbol);
      if (!monitorConfig) {
        return; // 未配置的监控标的，不缓存
      }

      // 只提取该监控标的配置中需要验证的指标（内存优化）
      // 使用对象池复用 indicators 对象，减少 GC 压力
      const indicators = extractConfiguredIndicators(
        snapshot,
        monitorConfig.indicatorsToCache,
      );

      // 如果没有有效的指标值，释放对象池对象并返回
      if (Object.keys(indicators).length === 0) {
        indicatorRecordPool.release(indicators);
        return;
      }

      // 获取或初始化环形缓冲区
      let buffer = cacheMap.get(monitorSymbol);
      if (!buffer) {
        buffer = new Array(monitorConfig.maxEntries);
        cacheMap.set(monitorSymbol, buffer);
        writeIndexMap.set(monitorSymbol, 0);
      }

      const writeIndex = writeIndexMap.get(monitorSymbol) ?? 0;
      
      // ⚠️ 重要：释放被覆盖位置的旧 indicators 对象回对象池
      const oldEntry = buffer[writeIndex];
      if (oldEntry?.indicators) {
        indicatorRecordPool.release(oldEntry.indicators);
      }

      // 写入环形缓冲区
      buffer[writeIndex] = {
        timestamp: Date.now(),
        indicators,
      };
      writeIndexMap.set(monitorSymbol, (writeIndex + 1) % monitorConfig.maxEntries);
    },

    getAt(
      monitorSymbol: string,
      targetTime: number,
      toleranceMs: number,
    ): IndicatorCacheEntry | null {
      const buffer = cacheMap.get(monitorSymbol);
      if (!buffer) {
        return null;
      }

      // ⚠️ 重要：选择最接近目标时间的数据，而不是第一个符合容差范围的数据
      // 参考 signalVerification 模块中 findBestMatch 的实现模式
      let bestMatch: IndicatorCacheEntry | null = null;
      let minTimeDiff = Infinity;

      for (const entry of buffer) {
        if (!entry) continue;
        
        const timeDiff = Math.abs(entry.timestamp - targetTime);
        if (timeDiff <= toleranceMs && timeDiff < minTimeDiff) {
          minTimeDiff = timeDiff;
          bestMatch = entry;
        }
      }

      return bestMatch;
    },

    // ... 其他方法实现

    clear(monitorSymbol: string): void {
      const buffer = cacheMap.get(monitorSymbol);
      if (buffer) {
        // 释放所有 indicators 对象回对象池
        for (const entry of buffer) {
          if (entry?.indicators) {
            indicatorRecordPool.release(entry.indicators);
          }
        }
        cacheMap.delete(monitorSymbol);
        writeIndexMap.delete(monitorSymbol);
      }
    },

    clearAll(): void {
      // 释放所有 indicators 对象回对象池
      for (const buffer of cacheMap.values()) {
        for (const entry of buffer) {
          if (entry?.indicators) {
            indicatorRecordPool.release(entry.indicators);
          }
        }
      }
      cacheMap.clear();
      writeIndexMap.clear();
    },
  };
}

/**
 * 只提取配置中需要验证的指标值（内存优化 + 对象池复用）
 * @param snapshot 指标快照
 * @param indicatorsToCache 需要缓存的指标列表
 * @returns 从对象池获取的 indicators 对象（调用方负责在不需要时释放）
 */
function extractConfiguredIndicators(
  snapshot: IndicatorSnapshot,
  indicatorsToCache: string[],
): Record<string, number> {
  // 从对象池获取 indicators 对象，减少内存分配
  const indicators = indicatorRecordPool.acquire();

  for (const indicatorName of indicatorsToCache) {
    // 使用已有的 getIndicatorValue 函数获取指标值
    const value = getIndicatorValue(snapshot, indicatorName);
    if (value !== null && Number.isFinite(value)) {
      indicators[indicatorName] = value;
    }
  }

  return indicators;
}

/**
 * 从验证配置中提取需要缓存的指标列表（去重后的并集）
 * @param verificationConfig 验证配置
 */
function extractIndicatorsToCache(verificationConfig: VerificationConfig): string[] {
  const indicatorSet = new Set<string>();

  // 从买入验证配置中提取
  if (verificationConfig.buy.indicators) {
    for (const indicator of verificationConfig.buy.indicators) {
      indicatorSet.add(indicator);
    }
  }

  // 从卖出验证配置中提取
  if (verificationConfig.sell.indicators) {
    for (const indicator of verificationConfig.sell.indicators) {
      indicatorSet.add(indicator);
    }
  }

  return Array.from(indicatorSet);
}
```

**内存优化效果**：

| 场景 | 优化前（提取所有指标） | 优化后（按需提取） |
|------|----------------------|-------------------|
| 配置验证指标 `['D', 'DIF']` | 存储 K, D, J, MACD, DIF, DEA, RSI:6, MFI, EMA:7 等 | 只存储 D, DIF |
| 单条记录内存占用 | ~100+ 字节 | ~20-30 字节 |
| 85 秒缓存总占用 | ~8.5KB | ~2KB |

#### 3.1.5 文件结构

```
src/program/indicatorCache/
├── index.ts          # 导出入口
├── indicatorCache.ts # 核心实现
└── types.ts          # 类型定义
```

---

### 3.2 延迟验证器模块 (DelayedSignalVerifier)

#### 3.2.1 设计目标

- **仅接收延迟信号**（立即信号直接推入任务队列，不经过本模块）
- 使用 setTimeout 自行计时，在 `triggerTime + READY_DELAY_SECONDS` 后执行验证
- 验证时间到达后，从指标缓存读取数据进行验证
- 验证通过后，将信号推入任务队列

#### 3.2.2 关键时间点说明

**信号时间线**：
```
信号生成时刻(now)        triggerTime = now + delaySeconds        验证执行时刻
    ↓                              ↓                                 ↓
    0s ───────────────────────> 60s ─────────────────────────────> 75s
                                 │                                   │
                                 │  T0=triggerTime                   │
                                 │  T1=T0+5s                         │
                                 │  T2=T0+10s                        │
                                 │                                   │
                                 └── 验证的 3 个时间点 ──────────────┘
                                     (在验证执行时从缓存读取)
```

**重要公式**：
- `triggerTime = now + delaySeconds`（由 strategy 模块计算，已包含延迟时间）
- `verifyTime = triggerTime + READY_DELAY_SECONDS`（验证执行时刻）
- `READY_DELAY_SECONDS = 15`（常量，确保 T2 数据已记录）

> **注意**：`triggerTime` 已经是 `now + delaySeconds`，验证时不需要再加 `delaySeconds`！

#### 3.2.3 接口定义

```typescript
/**
 * 单方向验证配置（买入或卖出）
 */
interface DirectionalVerificationConfig {
  /** 延迟验证时间（秒），默认 60，设为 0 表示不延迟验证 */
  delaySeconds: number;
  /** 验证指标列表，如 ['D', 'DIF']，为空表示不延迟验证 */
  indicators: string[];
}

/**
 * 延迟验证器配置（支持买卖独立配置）
 */
interface DelayedSignalVerifierConfig {
  /** 买入信号验证配置 */
  buy: DirectionalVerificationConfig;
  /** 卖出信号验证配置 */
  sell: DirectionalVerificationConfig;
  /** 验证时间容差（毫秒），默认 5000 */
  toleranceMs: number;
  /** 验证就绪延迟（秒），从常量 VERIFICATION.READY_DELAY_SECONDS 获取，默认 15 */
  readyDelaySeconds: number;
}

/**
 * 验证结果
 */
interface VerificationResult {
  /** 是否通过验证 */
  passed: boolean;
  /** 原因描述 */
  reason: string;
  /** 失败的指标列表（如果验证失败） */
  failedIndicators?: string[];
}

/**
 * 延迟验证器接口
 */
interface DelayedSignalVerifier {
  /**
   * 添加延迟信号（内部自动设置验证定时器）
   * @param signal 延迟信号
   * @param monitorSymbol 监控标的代码
   */
  addSignal(signal: Signal, monitorSymbol: string): void;

  /**
   * 取消指定信号的验证
   * @param signalId 信号ID
   * @returns 是否成功取消
   */
  cancelSignal(signalId: string): boolean;

  /**
   * 取消指定监控标的的所有待验证信号
   * @param monitorSymbol 监控标的代码
   */
  cancelAllForSymbol(monitorSymbol: string): void;

  /**
   * 获取待验证信号数量
   */
  getPendingCount(): number;

  /**
   * 获取指定监控标的的待验证信号数量
   */
  getPendingCountForSymbol(monitorSymbol: string): number;

  /**
   * 设置验证通过回调
   */
  onVerified(callback: (signal: Signal) => void): void;

  /**
   * 设置验证失败回调
   */
  onRejected(callback: (signal: Signal, reason: string) => void): void;

  /**
   * 销毁验证器（清理所有定时器）
   */
  destroy(): void;
}
```

#### 3.2.4 实现要点

```typescript
class DelayedSignalVerifierImpl implements DelayedSignalVerifier {
  private indicatorCache: IndicatorCache;
  private config: DelayedSignalVerifierConfig;
  private pendingTimers = new Map<string, NodeJS.Timeout>();
  private signalMonitorMap = new Map<string, string>(); // signalId -> monitorSymbol
  private onVerifiedCallback?: (signal: Signal) => void;
  private onRejectedCallback?: (signal: Signal, reason: string) => void;

  addSignal(signal: Signal, monitorSymbol: string): void {
    if (!signal.triggerTime) {
      logger.warn('[延迟验证器] 信号缺少 triggerTime，跳过');
      return;
    }

    const signalId = this.generateSignalId(signal);
    
    // 检查是否已存在相同信号
    if (this.pendingTimers.has(signalId)) {
      logger.debug(`[延迟验证器] 信号 ${signalId} 已存在，跳过重复添加`);
      return;
    }

    // ⚠️ 重要：triggerTime 已经是 now + delaySeconds（由 strategy 模块计算）
    // 验证时间 = triggerTime + READY_DELAY_SECONDS（确保 T2 数据已记录）
    // 不要再加 delaySeconds！
    const verifyTime = signal.triggerTime.getTime() + this.config.readyDelaySeconds * 1000;
    const delay = verifyTime - Date.now();

    if (delay <= 0) {
      // 已过验证时间，立即验证
      this.executeVerification(signal, monitorSymbol, signalId);
    } else {
      // 设置定时器
      const timer = setTimeout(() => {
        this.executeVerification(signal, monitorSymbol, signalId);
      }, delay);

      this.pendingTimers.set(signalId, timer);
      this.signalMonitorMap.set(signalId, monitorSymbol);

      logger.info(
        `[延迟验证器] 添加信号 ${signal.symbol} ${signal.action}，` +
        `将在 ${(delay / 1000).toFixed(1)} 秒后验证（triggerTime=${signal.triggerTime.toISOString()}）`
      );
    }
  }

  private executeVerification(
    signal: Signal,
    monitorSymbol: string,
    signalId: string,
  ): void {
    // 清理定时器和映射
    this.pendingTimers.delete(signalId);
    this.signalMonitorMap.delete(signalId);

    const result = this.verify(signal, monitorSymbol);

    if (result.passed) {
      logger.info(
        `[延迟验证通过] ${signal.symbol} ${signal.action}: ${result.reason}`
      );
      this.onVerifiedCallback?.(signal);
    } else {
      logger.info(
        `[延迟验证失败] ${signal.symbol} ${signal.action}: ${result.reason}`
      );
      this.onRejectedCallback?.(signal, result.reason);
    }
  }

  private verify(signal: Signal, monitorSymbol: string): VerificationResult {
    // ⚠️ 重要：triggerTime 已经是 now + delaySeconds（延迟后的触发时间点）
    // 验证的 3 个时间点：
    // - T0 = triggerTime（延迟后的触发时间）
    // - T1 = triggerTime + 5秒
    // - T2 = triggerTime + 10秒
    const triggerTime = signal.triggerTime!.getTime();
    const toleranceMs = this.config.toleranceMs;

    // 从缓存获取 3 个时间点的指标值
    // 使用常量 TIME_OFFSET_1_SECONDS(5) 和 TIME_OFFSET_2_SECONDS(10)
    const t0 = this.indicatorCache.getAt(monitorSymbol, triggerTime, toleranceMs);
    const t1 = this.indicatorCache.getAt(monitorSymbol, triggerTime + VERIFICATION.TIME_OFFSET_1_SECONDS * 1000, toleranceMs);
    const t2 = this.indicatorCache.getAt(monitorSymbol, triggerTime + VERIFICATION.TIME_OFFSET_2_SECONDS * 1000, toleranceMs);

    // 获取初始值（信号生成时记录的指标值）
    const initial = signal.indicators1;

    if (!t0 || !t1 || !t2) {
      return {
        passed: false,
        reason: `缓存中缺少必要的指标数据（T0=${!!t0}, T1=${!!t1}, T2=${!!t2}）`,
      };
    }

    if (!initial) {
      return {
        passed: false,
        reason: '信号缺少初始指标值 (indicators1)',
      };
    }

    // 获取验证配置（买入和卖出使用独立配置）
    const isBuySignal = signal.action === 'BUYCALL' || signal.action === 'BUYPUT';
    const dirConfig = isBuySignal ? this.config.buy : this.config.sell;
    const indicators = dirConfig.indicators;

    // 判断趋势方向
    const needRising = signal.action === 'BUYCALL' || signal.action === 'SELLPUT';

    const failedIndicators: string[] = [];
    const details: string[] = [];

    for (const indicatorName of indicators) {
      const vInitial = initial[indicatorName];
      const v0 = t0.indicators[indicatorName];
      const v1 = t1.indicators[indicatorName];
      const v2 = t2.indicators[indicatorName];

      if (!Number.isFinite(vInitial) || !Number.isFinite(v0) || 
          !Number.isFinite(v1) || !Number.isFinite(v2)) {
        failedIndicators.push(indicatorName);
        continue;
      }

      let passed: boolean;
      if (needRising) {
        passed = v0 > vInitial && v1 > vInitial && v2 > vInitial;
      } else {
        passed = v0 < vInitial && v1 < vInitial && v2 < vInitial;
      }

      if (!passed) {
        failedIndicators.push(indicatorName);
      }

      details.push(
        `${indicatorName}: initial=${vInitial.toFixed(3)} ` +
        `T0=${v0.toFixed(3)} T1=${v1.toFixed(3)} T2=${v2.toFixed(3)}`
      );
    }

    if (failedIndicators.length > 0) {
      return {
        passed: false,
        reason: `指标验证失败: ${failedIndicators.join(', ')}; ${details.join('; ')}`,
        failedIndicators,
      };
    }

    return {
      passed: true,
      reason: details.join('; '),
    };
  }

  private generateSignalId(signal: Signal): string {
    return `${signal.symbol}_${signal.action}_${signal.triggerTime?.getTime() ?? 0}`;
  }
}
```

#### 3.2.4 文件结构

```
src/program/delayedSignalVerifier/
├── index.ts                    # 导出入口
├── delayedSignalVerifier.ts    # 核心实现
└── types.ts                    # 类型定义
```

---

### 3.3 任务队列模块 (TradeTaskQueue)

#### 3.3.1 设计目标

- 缓冲待处理的**常规交易任务**
- 支持两种任务来源：
  - **立即信号**：未配置延迟验证的信号，直接入队
  - **已验证信号**：延迟验证通过的信号
- FIFO 顺序处理任务
- 简单高效，无优先级机制

> **注意**：保护性清仓和末日保护不经过任务队列，在主循环中直接同步执行，确保实时响应。

#### 3.3.2 接口定义

```typescript
/**
 * 任务类型
 */
type TaskType = 
  | 'IMMEDIATE_SIGNAL'  // 立即信号（未配置延迟验证）
  | 'VERIFIED_SIGNAL';  // 验证通过的延迟信号

/**
 * 交易任务
 */
interface TradeTask {
  /** 任务ID */
  id: string;
  /** 任务类型 */
  type: TaskType;
  /** 任务数据（信号对象） */
  data: Signal;
  /** 监控标的代码 */
  monitorSymbol: string;
  /** 创建时间戳 */
  createdAt: number;
}

/**
 * 任务队列接口
 */
interface TradeTaskQueue {
  /**
   * 添加任务
   */
  push(task: Omit<TradeTask, 'id' | 'createdAt'>): void;

  /**
   * 获取下一个任务（FIFO 顺序）
   */
  pop(): TradeTask | null;

  /**
   * 查看下一个任务（不移除）
   */
  peek(): TradeTask | null;

  /**
   * 获取队列长度
   */
  size(): number;

  /**
   * 检查队列是否为空
   */
  isEmpty(): boolean;

  /**
   * 清空队列
   */
  clear(): void;

  /**
   * 设置任务添加回调（用于触发处理器）
   */
  onTaskAdded(callback: () => void): void;
}
```

#### 3.3.3 文件结构

```
src/program/tradeTaskQueue/
├── index.ts          # 导出入口
├── tradeTaskQueue.ts # 核心实现
└── types.ts          # 类型定义
```

---

### 3.4 交易处理器模块 (TradeProcessor)

#### 3.4.1 设计目标

- 消费任务队列中的**常规交易任务**
  - **立即信号**：直接执行风险检查和订单提交
  - **已验证信号**：延迟验证通过后执行风险检查和订单提交
- 执行风险检查、卖出计算、订单提交
- 使用 setImmediate 异步执行，不阻塞主循环

> **注意**：保护性清仓和末日保护在主循环中直接同步执行，不经过交易处理器。

#### 3.4.2 接口定义

```typescript
/**
 * 交易处理器配置
 */
interface TradeProcessorConfig {
  /** 批量处理的最大任务数 */
  maxBatchSize: number;
  /** 处理间隔（毫秒） */
  processIntervalMs: number;
}

/**
 * 交易处理器接口
 */
interface TradeProcessor {
  /**
   * 启动处理器
   */
  start(): void;

  /**
   * 停止处理器
   */
  stop(): void;

  /**
   * 立即处理队列中的任务（不等待间隔）
   */
  processNow(): Promise<void>;

  /**
   * 检查处理器是否运行中
   */
  isRunning(): boolean;

  /**
   * 获取处理统计
   */
  getStats(): ProcessorStats;
}

/**
 * 处理统计
 */
interface ProcessorStats {
  /** 已处理任务数 */
  processedCount: number;
  /** 成功数 */
  successCount: number;
  /** 失败数 */
  failedCount: number;
  /** 最后处理时间 */
  lastProcessedAt: number | null;
}
```

#### 3.4.3 实现要点

```typescript
class TradeProcessorImpl implements TradeProcessor {
  private taskQueue: TradeTaskQueue;
  private trader: Trader;
  private signalProcessor: SignalProcessor;
  private monitorContexts: Map<string, MonitorContext>;
  
  private running = false;
  private stats: ProcessorStats = {
    processedCount: 0,
    successCount: 0,
    failedCount: 0,
    lastProcessedAt: null,
  };

  start(): void {
    if (this.running) return;
    this.running = true;
    
    // 监听任务添加事件，立即触发处理
    this.taskQueue.onTaskAdded(() => {
      if (this.running) {
        setImmediate(() => this.processNow());
      }
    });
    
    logger.info('[交易处理器] 已启动');
  }

  async processNow(): Promise<void> {
    // FIFO 顺序处理任务
    while (!this.taskQueue.isEmpty()) {
      const task = this.taskQueue.pop();
      if (!task) break;

      try {
        await this.processVerifiedSignal(task.data, task.monitorSymbol);
        this.stats.successCount++;
      } catch (err) {
        this.stats.failedCount++;
        logger.error(`[交易处理器] 任务处理失败: ${task.type}`, err);
      }

      this.stats.processedCount++;
      this.stats.lastProcessedAt = Date.now();
    }
  }

  private async processVerifiedSignal(
    signal: Signal,
    monitorSymbol: string,
  ): Promise<void> {
    // 1. 获取监控上下文
    const context = this.getMonitorContext(monitorSymbol);
    if (!context) {
      logger.warn(`[交易处理器] 未找到监控上下文: ${monitorSymbol}`);
      signalObjectPool.release(signal);
      return;
    }

    try {
      // 2. 构建风险检查上下文（使用 MonitorContext 中的缓存行情数据）
      // 注意：行情数据由主循环每秒更新，并通过 WebSocket 订阅实时同步
      const riskCheckContext = this.buildRiskCheckContext(signal, context);
      
      // 3. 执行风险检查（任何失败直接拒绝，不重试）
      const [checkedSignal] = await this.signalProcessor.applyRiskChecks(
        [signal],
        riskCheckContext,
      );

      if (!checkedSignal) {
        logger.info(`[交易处理器] 信号未通过风险检查: ${signal.symbol} ${signal.action}`);
        return; // finally 块统一释放
      }

      // 4. 卖出信号处理（成本价判断、数量计算）
      if (signal.action === 'SELLCALL' || signal.action === 'SELLPUT') {
        this.signalProcessor.processSellSignals(
          [signal],
          context.longPosition,
          context.shortPosition,
          context.longQuote,
          context.shortQuote,
          context.orderRecorder,
          context.config.smartCloseEnabled,
        );

        if (signal.action === 'HOLD') {
          logger.info(`[交易处理器] 卖出信号被设为 HOLD: ${signal.symbol}`);
          return; // finally 块统一释放
        }
      }

      // 5. 执行订单（任何失败直接记录日志，不重试）
      await this.trader.executeSignals([signal]);

    } finally {
      // 6. 统一释放信号对象（无论成功、失败或拒绝）
      signalObjectPool.release(signal);
    }
  }

  private getMonitorContext(monitorSymbol: string): MonitorContext | undefined {
    return this.monitorContexts.get(monitorSymbol);
  }

  private buildRiskCheckContext(signal: Signal, context: MonitorContext): RiskCheckContext {
    // 构建风险检查上下文，从 context 中获取必要的数据
    // ... 实现细节
  }
}
```

#### 3.4.4 文件结构

```
src/program/tradeProcessor/
├── index.ts           # 导出入口
├── tradeProcessor.ts  # 核心实现
└── types.ts           # 类型定义
```

---

## 四、主循环改造

### 4.1 改造后的 runOnce 流程

```typescript
async function runOnce(context: RunOnceContext): Promise<void> {
  const {
    marketDataClient,
    trader,
    lastState,
    marketMonitor,
    doomsdayProtection,   // 保留：末日保护同步执行
    indicatorCache,       // 新增
    delayedSignalVerifier, // 新增
    monitorContexts,
  } = context;

  // 1. 交易日检查（保持不变）
  // ...

  // 2. 交易时段检查（保持不变）
  // ...

  // 3. 末日保护检测（同步执行，确保时效）
  // ⚠️ 保留在主循环中直接执行，不推入任务队列
  if (MULTI_MONITOR_TRADING_CONFIG.global.doomsdayProtection) {
    // 收盘前 15 分钟撤单（同步执行）
    const cancelResult = await doomsdayProtection.cancelPendingBuyOrders({
      currentTime,
      isHalfDay,
      monitorConfigs: MULTI_MONITOR_TRADING_CONFIG.monitors,
      trader,
    });

    if (cancelResult.executed && cancelResult.cancelledCount > 0) {
      logger.info(`[末日保护程序] 收盘前15分钟撤单完成，共撤销 ${cancelResult.cancelledCount} 个买入订单`);
    }

    // 收盘前 5 分钟清仓（同步执行）
    const clearanceResult = await doomsdayProtection.executeClearance({
      currentTime,
      isHalfDay,
      positions: lastState.cachedPositions,
      monitorConfigs: MULTI_MONITOR_TRADING_CONFIG.monitors,
      monitorContexts,
      trader,
      marketDataClient,
      lastState,
    });

    if (clearanceResult.executed) {
      // 末日保护已执行清仓，跳过本次循环的监控标的处理
      return;
    }
  }

  // 4. 批量获取行情（保持不变）
  const allQuoteSymbols = collectAllQuoteSymbols(MULTI_MONITOR_TRADING_CONFIG.monitors);
  const quotesMap = await marketDataClient.getQuotes(allQuoteSymbols);

  // 5. 并发处理所有监控标的（简化后）
  const monitorTasks: Promise<void>[] = [];
  for (const [monitorSymbol, monitorContext] of monitorContexts) {
    monitorTasks.push(
      processMonitorSimplified({
        monitorContext,
        marketDataClient,
        marketMonitor,
        indicatorCache,
        delayedSignalVerifier,
        globalState: lastState,
        currentTime,
        isHalfDay,
        canTradeNow,
      }, quotesMap)
    );
  }

  await Promise.allSettled(monitorTasks);

  // 6. 订单监控（保持不变）
  // ...
}
```

### 4.2 改造后的 processMonitor 流程

```typescript
async function processMonitorSimplified(
  context: ProcessMonitorContext,
  quotesMap: ReadonlyMap<string, Quote | null>,
): Promise<void> {
  const {
    monitorContext,
    marketDataClient,
    trader,
    marketMonitor,
    indicatorCache,
    delayedSignalVerifier,
    tradeTaskQueue,
    globalState,
  } = context;

  const { config, state, strategy, orderRecorder, riskChecker, unrealizedLossMonitor } = monitorContext;
  const MONITOR_SYMBOL = config.monitorSymbol;

  // 1. 提取行情（保持不变）
  const longQuote = quotesMap.get(config.longSymbol) ?? null;
  const shortQuote = quotesMap.get(config.shortSymbol) ?? null;
  const monitorQuote = quotesMap.get(MONITOR_SYMBOL) ?? null;

  // 2. 价格监控显示（保持不变）
  const priceChanged = marketMonitor.monitorPriceChanges(...);

  // 3. 浮亏检测与保护性清仓（同步执行，确保实时响应）
  // ⚠️ 保留在主循环中直接执行，不推入任务队列
  if (priceChanged) {
    await unrealizedLossMonitor.monitorUnrealizedLoss(
      longQuote,
      shortQuote,
      config.longSymbol,
      config.shortSymbol,
      riskChecker,
      trader,
      orderRecorder,
    );
  }

  // 4. 获取 K 线（保持不变）
  const monitorCandles = await marketDataClient.getCandlesticks(...);
  if (!monitorCandles || monitorCandles.length === 0) {
    return;
  }

  // 5. 计算指标
  const monitorSnapshot = buildIndicatorSnapshot(...);

  // 6. 【新增】将指标存入缓存（供延迟验证使用）
  indicatorCache.push(MONITOR_SYMBOL, monitorSnapshot);

  // 7. 指标监控显示（保持不变）
  marketMonitor.monitorIndicatorChanges(...);

  // 8. 生成信号（返回立即信号和延迟信号）
  const { immediateSignals, delayedSignals } = strategy.generateCloseSignals(
    monitorSnapshot,
    config.longSymbol,
    config.shortSymbol,
    orderRecorder,
  );

  // 9. 【改造】信号分流处理
  // 9.1 立即信号：直接推入任务队列
  for (const signal of immediateSignals) {
    tradeTaskQueue.push({
      type: 'IMMEDIATE_SIGNAL',
      data: signal,
      monitorSymbol: MONITOR_SYMBOL,
    });
  }

  // 9.2 延迟信号：推入延迟验证器
  for (const signal of delayedSignals) {
    delayedSignalVerifier.addSignal(signal, MONITOR_SYMBOL);
  }

  // 10. 【移除】以下逻辑已移至交易处理器：
  // - signalVerificationManager.recordVerificationHistory()
  // - signalVerificationManager.verifyPendingSignals()
  // - signalProcessor.applyRiskChecks()
  // - signalProcessor.processSellSignals()
  // - trader.executeSignals()
}
```

> **信号分流逻辑说明**：
> - `immediateSignals`：当 `delaySeconds = 0` 或 `indicators` 为空时生成，直接推入任务队列
> - `delayedSignals`：当 `delaySeconds > 0` 且 `indicators` 非空时生成，推入延迟验证器等待验证

---

## 五、模块依赖关系

### 5.1 依赖图

```
┌─────────────────────────────────────────────────────────────────────┐
│                           主循环 (index.ts)                          │
│                                                                     │
│  • 浮亏检测与保护性清仓（同步执行）                                   │
│  • 末日保护（同步执行）                                              │
└───────────┬─────────────────┬─────────────────┬─────────────────────┘
            │                 │                 │
            ▼                 ▼                 ▼
┌───────────────────┐ ┌─────────────────┐ ┌─────────────────────────────┐
│   IndicatorCache  │ │  TradeTaskQueue │ │  DelayedSignalVerifier      │
│                   │ │                 │ │                             │
│   (无外部依赖)     │ │   (无外部依赖)   │ │  依赖: IndicatorCache       │
│                   │ │  仅常规交易信号  │ │        VerificationConfig   │
└───────────────────┘ └────────┬────────┘ └──────────────┬──────────────┘
                               │                         │
                               │    推入验证通过的信号    │
                               │◀────────────────────────┘
                               │
                               ▼
                    ┌─────────────────────┐
                    │    TradeProcessor   │
                    │                     │
                    │  依赖: Trader       │
                    │        SignalProcessor
                    │        MonitorContexts│
                    │  仅处理常规交易信号  │
                    └─────────────────────┘
```

### 5.2 初始化顺序

```typescript
import { VERIFICATION } from './constants/index.js';

// 0. 为每个监控标的计算指标缓存配置（按需提取优化）
const monitorCacheConfigs = new Map<string, MonitorIndicatorCacheConfig>();

for (const monitorConfig of MULTI_MONITOR_TRADING_CONFIG.monitors) {
  const verificationConfig = monitorConfig.verificationConfig;
  
  // 计算该监控标的的最大延迟时间
  const buyDelay = verificationConfig?.buy.delaySeconds ?? 60;
  const sellDelay = verificationConfig?.sell.delaySeconds ?? 60;
  const maxDelaySeconds = Math.max(buyDelay, sellDelay, 60);  // 最小 60 秒
  
  // 提取需要缓存的指标列表（买入和卖出验证指标的并集，去重）
  const indicatorsToCache = extractIndicatorsToCache(verificationConfig);
  
  // 如果没有需要缓存的指标（配置了立即执行），跳过缓存配置
  if (indicatorsToCache.length === 0) {
    continue;
  }
  
  monitorCacheConfigs.set(monitorConfig.monitorSymbol, {
    maxEntries: maxDelaySeconds + VERIFICATION.WINDOW_END_OFFSET_SECONDS + 10,
    indicatorsToCache,
  });
}

// 1. 基础模块（无依赖）
const indicatorCache = createIndicatorCache({
  monitorConfigs: monitorCacheConfigs,  // 按需提取配置
});
const tradeTaskQueue = createTradeTaskQueue();

// 2. 延迟验证器（依赖指标缓存，支持买卖独立配置）
const delayedSignalVerifier = createDelayedSignalVerifier({
  indicatorCache,
  config: {
    buy: {
      delaySeconds: 60,  // 买入延迟60秒验证（可配置）
      indicators: ['D', 'DIF'],  // 买入验证指标（可配置）
    },
    sell: {
      delaySeconds: 60,  // 卖出延迟60秒验证（可配置）
      indicators: ['D', 'DIF'],  // 卖出验证指标（可配置）
    },
    toleranceMs: VERIFICATION.TIME_TOLERANCE_MS,  // 时间容差5秒（常量）
    readyDelaySeconds: VERIFICATION.READY_DELAY_SECONDS,  // 验证就绪延迟15秒（常量）
  },
  onVerified: (signal) => {
    // 验证通过后推入任务队列
    const monitorSymbol = findMonitorSymbolByTradingSymbol(signal.symbol);
    tradeTaskQueue.push({
      type: 'VERIFIED_SIGNAL',
      data: signal,
      monitorSymbol,
    });
  },
  onRejected: (signal, reason) => {
    // 验证失败，释放信号对象（由延迟验证器负责）
    logger.info(`[延迟验证失败] ${signal.symbol} ${signal.action}: ${reason}`);
    signalObjectPool.release(signal);
  },
});

// 3. 交易处理器（处理立即信号 + 已验证信号）
const tradeProcessor = createTradeProcessor({
  taskQueue: tradeTaskQueue,
  trader,
  signalProcessor,
  monitorContexts,
});

// 4. 启动交易处理器
tradeProcessor.start();

// 注意：浮亏保护和末日保护不依赖任务队列和交易处理器
// 它们在主循环中直接同步执行，确保实时响应
```

**辅助函数：提取需要缓存的指标列表**

```typescript
/**
 * 从验证配置中提取需要缓存的指标列表（去重后的并集）
 * @param verificationConfig 验证配置
 * @returns 需要缓存的指标列表，如果配置了立即执行则返回空数组
 */
function extractIndicatorsToCache(
  verificationConfig: VerificationConfig | null | undefined,
): string[] {
  if (!verificationConfig) {
    return [];
  }

  const indicatorSet = new Set<string>();

  // 从买入验证配置中提取（仅当需要延迟验证时）
  if (
    verificationConfig.buy.delaySeconds > 0 &&
    verificationConfig.buy.indicators?.length > 0
  ) {
    for (const indicator of verificationConfig.buy.indicators) {
      indicatorSet.add(indicator);
    }
  }

  // 从卖出验证配置中提取（仅当需要延迟验证时）
  if (
    verificationConfig.sell.delaySeconds > 0 &&
    verificationConfig.sell.indicators?.length > 0
  ) {
    for (const indicator of verificationConfig.sell.indicators) {
      indicatorSet.add(indicator);
    }
  }

  return Array.from(indicatorSet);
}
```

---

## 六、立即信号支持改造（重要）

> **⚠️ 当前问题**：现有程序**不支持立即信号**。当配置 `delaySeconds=0` 或 `indicators=[]` 时，信号会被丢弃而非作为立即信号处理。重构时必须修复此问题。

### 6.1 当前代码问题分析

#### 6.1.1 问题定位

在 `src/core/strategy/index.ts` 中，`generateDelayedSignal` 函数存在以下问题：

```typescript
// 当前代码（第 241-247 行）
const triggerTime = calculateVerificationTime(isBuySignal);
// 如果不需要延迟验证（triggerTime 为 null），则返回 null
// 这种情况下，信号应该被当作立即执行的信号处理
if (!triggerTime) {
  return null;  // ← 问题：信号被丢弃！
}
```

`calculateVerificationTime` 函数的逻辑（第 105-129 行）：

```typescript
const calculateVerificationTime = (isBuySignal: boolean): Date | null => {
  const config = isBuySignal ? finalVerificationConfig.buy : finalVerificationConfig.sell;

  // 如果延迟时间为 0 或指标列表为空，则不进行延迟验证
  if (
    !config.delaySeconds ||
    config.delaySeconds === 0 ||
    !config.indicators ||
    config.indicators.length === 0
  ) {
    return null;  // ← 返回 null 导致信号被丢弃
  }
  // ...
};
```

#### 6.1.2 问题影响

| 配置 | 期望行为 | 当前行为 |
|------|---------|---------|
| `delaySeconds=60, indicators=['D','DIF']` | 生成延迟信号 | ✓ 正常 |
| `delaySeconds=0, indicators=['D','DIF']` | 生成立即信号 | ✗ 信号丢弃 |
| `delaySeconds=60, indicators=[]` | 生成立即信号 | ✗ 信号丢弃 |
| `delaySeconds=0, indicators=[]` | 生成立即信号 | ✗ 信号丢弃 |

这导致 `generateCloseSignals` 返回的 `immediateSignals` **始终为空数组**。

### 6.2 改造方案

#### 6.2.1 修改文件清单

| 文件 | 修改内容 |
|------|---------|
| `src/core/strategy/index.ts` | 改造 `generateDelayedSignal` 支持立即信号 |
| `src/core/strategy/types.ts` | 无需修改（`SignalGenerationResult` 已正确定义） |

#### 6.2.2 strategy 模块改造

**改造目标**：将 `generateDelayedSignal` 函数改造为 `generateSignal`，根据配置返回立即信号或延迟信号。

**性能优化：信号类型预计算**

由于验证配置是不可变的（通过闭包捕获），每种信号类型是否需要延迟验证是**静态可知**的。在策略创建时预计算这个映射，避免每次信号生成时重复判断：

```typescript
// 在 createHangSengMultiIndicatorStrategy 函数内部，策略创建时预计算
// 预计算每种信号类型是否需要延迟验证（静态可知，只计算一次）
const signalTypeMap: Record<string, 'immediate' | 'delayed'> = {
  BUYCALL: needsDelayedVerification(finalVerificationConfig.buy) ? 'delayed' : 'immediate',
  SELLCALL: needsDelayedVerification(finalVerificationConfig.sell) ? 'delayed' : 'immediate',
  BUYPUT: needsDelayedVerification(finalVerificationConfig.buy) ? 'delayed' : 'immediate',
  SELLPUT: needsDelayedVerification(finalVerificationConfig.sell) ? 'delayed' : 'immediate',
};

/**
 * 判断是否需要延迟验证（纯函数）
 */
function needsDelayedVerification(config: SingleVerificationConfig): boolean {
  return (
    config.delaySeconds > 0 &&
    config.indicators != null &&
    config.indicators.length > 0
  );
}
```

**改造后的 generateSignal 函数**：

```typescript
/**
 * 生成交易信号（支持立即信号和延迟信号）
 * 
 * @returns 信号对象，包含 isImmediate 标识
 */
const generateSignal = (
  state: IndicatorSnapshot,
  symbol: string,
  action: string,
  reasonPrefix: string,
  orderRecorder: OrderRecorder | null,
  isLongSymbol: boolean,
): { signal: Signal; isImmediate: boolean } | null => {
  // 1. 验证所有必要的指标值是否有效
  if (!validateAllIndicators(state)) {
    return null;
  }

  // 2. 对于卖出信号，检查订单记录中是否有买入订单记录
  if (action === 'SELLCALL' || action === 'SELLPUT') {
    if (!orderRecorder) {
      return null;
    }
    const buyOrders = orderRecorder.getBuyOrdersForSymbol(symbol, isLongSymbol);
    if (!buyOrders || buyOrders.length === 0) {
      return null;
    }
  }

  // 3. 获取该信号类型的配置并评估条件
  const signalConfig = getSignalConfigForType(action);
  if (!signalConfig) {
    return null;
  }

  const evalResult = evaluateSignalConfig(state, signalConfig);
  if (!evalResult.triggered) {
    return null;
  }

  // 4. 判断是买入还是卖出信号，获取验证配置
  const isBuySignal = action === 'BUYCALL' || action === 'BUYPUT';
  const verificationConfig = isBuySignal
    ? finalVerificationConfig.buy
    : finalVerificationConfig.sell;

  // 5. 使用预计算的信号类型映射（O(1) 查找，无需每次判断）
  const isImmediate = signalTypeMap[action] === 'immediate';

  // 6. 构建信号对象
  const signal = signalObjectPool.acquire() as Signal;
  signal.symbol = symbol;
  signal.action = action as SignalType;

  if (!isImmediate) {
    // === 延迟信号 ===
    const triggerTime = calculateVerificationTime(isBuySignal);
    if (!triggerTime) {
      // 防御性检查：理论上不应该发生
      signalObjectPool.release(signal);
      return null;
    }

    // 记录初始指标值（用于验证）
    const indicators1 = indicatorRecordPool.acquire();
    for (const indicatorName of verificationConfig.indicators) {
      const value = getIndicatorValue(state, indicatorName);
      if (value === null) {
        indicatorRecordPool.release(indicators1);
        signalObjectPool.release(signal);
        return null;
      }
      indicators1[indicatorName] = value;
    }

    // 构建延迟信号的 reason
    const indicators1Str = Object.entries(indicators1)
      .map(([name, value]) => `${name}1=${value.toFixed(3)}`)
      .join(' ');
    const indicatorDisplayStr = buildIndicatorDisplayString(state);

    signal.triggerTime = triggerTime;
    signal.indicators1 = indicators1;
    signal.verificationHistory = [];
    signal.reason = `${reasonPrefix}：${evalResult.reason}，${indicatorDisplayStr}，${indicators1Str}，将在 ${triggerTime.toLocaleString('zh-CN', { timeZone: 'Asia/Hong_Kong', hour12: false })} 进行验证`;

    return { signal, isImmediate: false };
  } else {
    // === 立即信号（使用预计算的 signalTypeMap 确定） ===
    signal.triggerTime = null;
    signal.indicators1 = null;
    signal.verificationHistory = null;
    signal.reason = `立即执行信号：${evalResult.reason}，${buildIndicatorDisplayString(state)}`;

    return { signal, isImmediate: true };
  }
};
```

**优化效果**：

| 优化前 | 优化后 |
|--------|--------|
| 每次信号生成时判断 `delaySeconds > 0 && indicators.length > 0` | 策略创建时预计算，信号生成时 O(1) 查表 |
| 运行时条件判断 4 次（每种信号类型各 1 次） | 初始化时计算 1 次 |
```

#### 6.2.3 generateCloseSignals 改造

```typescript
return {
  generateCloseSignals: (
    state: IndicatorSnapshot | null,
    longSymbol: string,
    shortSymbol: string,
    orderRecorder: OrderRecorder,
  ): SignalGenerationResult => {
    const immediateSignals: Signal[] = [];
    const delayedSignals: Signal[] = [];

    if (!state || !validateBasicIndicators(state)) {
      return { immediateSignals, delayedSignals };
    }

    // 定义所有需要检查的信号类型
    const signalChecks = [
      { symbol: longSymbol, action: 'BUYCALL', prefix: '买入做多信号', isLong: true },
      { symbol: longSymbol, action: 'SELLCALL', prefix: '卖出做多信号', isLong: true },
      { symbol: shortSymbol, action: 'BUYPUT', prefix: '买入做空信号', isLong: false },
      { symbol: shortSymbol, action: 'SELLPUT', prefix: '卖出做空信号', isLong: false },
    ];

    for (const { symbol, action, prefix, isLong } of signalChecks) {
      if (!symbol) continue;

      const result = generateSignal(
        state,
        symbol,
        action,
        prefix,
        orderRecorder,
        isLong,
      );

      if (result) {
        if (result.isImmediate) {
          immediateSignals.push(result.signal);
        } else {
          delayedSignals.push(result.signal);
        }
      }
    }

    return { immediateSignals, delayedSignals };
  },
};
```

### 6.3 信号类型判断逻辑

```typescript
/**
 * 判断是否需要延迟验证
 * @param isBuySignal 是否为买入信号
 * @param verificationConfig 验证配置
 * @returns true = 需要延迟验证，false = 立即执行
 */
function needsDelayedVerification(
  isBuySignal: boolean,
  verificationConfig: VerificationConfig,
): boolean {
  const config = isBuySignal ? verificationConfig.buy : verificationConfig.sell;
  
  // 需要延迟验证的条件：delaySeconds > 0 且 indicators 非空
  return (
    config.delaySeconds > 0 &&
    config.indicators != null &&
    config.indicators.length > 0
  );
}
```

### 6.4 主循环信号分流逻辑

```typescript
// 生成信号（改造后会正确返回 immediateSignals 和 delayedSignals）
const { immediateSignals, delayedSignals } = strategy.generateCloseSignals(
  monitorSnapshot,
  config.longSymbol,
  config.shortSymbol,
  orderRecorder,
);

// 信号分流
for (const signal of immediateSignals) {
  // 立即信号：直接推入任务队列
  tradeTaskQueue.push({
    type: 'IMMEDIATE_SIGNAL',
    data: signal,
    monitorSymbol: MONITOR_SYMBOL,
  });
}

for (const signal of delayedSignals) {
  // 延迟信号：推入延迟验证器
  delayedSignalVerifier.addSignal(signal, MONITOR_SYMBOL);
}
```

### 6.5 配置示例

```env
# 买入信号延迟验证（默认配置）
VERIFICATION_DELAY_SECONDS_BUY_1=60
VERIFICATION_INDICATORS_BUY_1=D,DIF

# 卖出信号立即执行（设置 delaySeconds=0 或 indicators 为空）
VERIFICATION_DELAY_SECONDS_SELL_1=0
VERIFICATION_INDICATORS_SELL_1=

# 或者两者都延迟验证
VERIFICATION_DELAY_SECONDS_BUY_1=60
VERIFICATION_INDICATORS_BUY_1=D,DIF
VERIFICATION_DELAY_SECONDS_SELL_1=30
VERIFICATION_INDICATORS_SELL_1=K,D
```

### 6.6 改造后的信号流程图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    strategy.generateCloseSignals()                       │
│                                                                         │
│  对每个信号类型 (BUYCALL, SELLCALL, BUYPUT, SELLPUT):                    │
│                                                                         │
│    1. 验证指标有效性                                                     │
│    2. 卖出信号检查订单记录                                               │
│    3. 评估信号条件                                                       │
│    4. 判断验证配置:                                                      │
│       ├── delaySeconds > 0 且 indicators 非空                           │
│       │   → 生成延迟信号 (设置 triggerTime, indicators1)                 │
│       │   → 加入 delayedSignals[]                                       │
│       │                                                                 │
│       └── delaySeconds = 0 或 indicators 为空                           │
│           → 生成立即信号 (triggerTime = null)                            │
│           → 加入 immediateSignals[]                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
                     ┌───────────────────────┐
                     │ { immediateSignals,   │
                     │   delayedSignals }    │
                     └───────────┬───────────┘
                                 │
              ┌──────────────────┴──────────────────┐
              ▼                                     ▼
    ┌─────────────────────┐              ┌─────────────────────┐
    │   immediateSignals  │              │   delayedSignals    │
    │   (立即信号)         │              │   (延迟信号)         │
    └──────────┬──────────┘              └──────────┬──────────┘
               │                                    │
               ▼                                    ▼
    ┌─────────────────────┐              ┌─────────────────────┐
    │    任务队列          │              │    延迟验证器        │
    │  (IMMEDIATE_SIGNAL) │              │  (setTimeout 计时)  │
    └──────────┬──────────┘              └──────────┬──────────┘
               │                                    │
               │                     ┌──────────────┴──────────────┐
               │                     ▼                             ▼
               │              验证通过                         验证失败
               │                     │                             │
               │                     ▼                             ▼
               │    ┌─────────────────────────┐         释放信号对象
               │    │    任务队列              │
               │    │  (VERIFIED_SIGNAL)      │
               │    └────────────┬────────────┘
               │                 │
               └────────┬────────┘
                        ▼
              ┌─────────────────────┐
              │    交易处理器        │
              │  (TradeProcessor)   │
              └─────────────────────┘
```

---

## 七、实施计划

### 7.1 阶段划分

| 阶段 | 内容 | 预计工作量 |
|------|------|-----------|
| **阶段 0** | 改造 strategy 模块支持立即信号（前置依赖） | 中 |
| **阶段 1** | 实现 IndicatorCache 模块（按需提取优化） | 小 |
| **阶段 2** | 实现 TradeTaskQueue 模块 | 小 |
| **阶段 3** | 实现 DelayedSignalVerifier 模块 | 中 |
| **阶段 4** | 实现 TradeProcessor 模块 | 中 |
| **阶段 5** | 改造主循环 | 中 |
| **阶段 6** | 集成测试与调优 | 中 |

### 7.2 详细步骤

#### 阶段 0：改造 strategy 模块支持立即信号（前置依赖）

> **⚠️ 重要**：此阶段必须在其他阶段之前完成，是整个重构的前置依赖。

1. 修改 `src/core/strategy/index.ts`：
   - 将 `generateDelayedSignal` 函数重命名为 `generateSignal`
   - 添加 `isImmediate` 返回值标识信号类型
   - 当 `delaySeconds=0` 或 `indicators=[]` 时生成立即信号
2. 修改 `generateCloseSignals` 方法，正确分流立即信号和延迟信号
3. 编写单元测试验证：
   - 配置延迟验证时生成延迟信号
   - 配置不延迟验证时生成立即信号
   - `immediateSignals` 和 `delayedSignals` 正确分流

**验收标准**：
```typescript
// 配置 delaySeconds=0 时
const result = strategy.generateCloseSignals(...);
expect(result.immediateSignals.length).toBeGreaterThan(0);  // 应有立即信号
expect(result.immediateSignals[0].triggerTime).toBeNull();  // 无 triggerTime
```

#### 阶段 1：实现 IndicatorCache 模块

1. 创建 `src/program/indicatorCache/` 目录结构
2. 实现 `types.ts` 定义接口（包含 `MonitorIndicatorCacheConfig`）
3. 实现 `indicatorCache.ts` 核心逻辑：
   - 按需提取指标（只缓存配置中需要验证的指标）
   - 环形缓冲区管理
   - 动态容量计算
4. 实现 `extractIndicatorsToCache` 辅助函数
5. 编写单元测试验证：
   - 环形缓冲区功能
   - 按需提取只缓存配置的指标
   - 时间范围查询

#### 阶段 2：实现 TradeTaskQueue 模块

1. 创建 `src/program/tradeTaskQueue/` 目录结构
2. 实现 `types.ts` 定义接口
3. 实现 `tradeTaskQueue.ts` 核心逻辑（简单 FIFO 队列，无优先级）
4. 编写单元测试验证 FIFO 顺序

#### 阶段 3：实现 DelayedSignalVerifier 模块

1. 创建 `src/program/delayedSignalVerifier/` 目录结构
2. 实现 `types.ts` 定义接口
3. 实现 `delayedSignalVerifier.ts` 核心逻辑
4. 集成 IndicatorCache，实现从缓存读取指标
5. 编写单元测试验证定时器和验证逻辑

#### 阶段 4：实现 TradeProcessor 模块

1. 创建 `src/program/tradeProcessor/` 目录结构
2. 实现 `types.ts` 定义接口
3. 实现 `tradeProcessor.ts` 核心逻辑
4. 集成 TradeTaskQueue、Trader、SignalProcessor 等
5. 编写集成测试验证任务处理流程

#### 阶段 5：改造主循环

1. 修改 `src/index.ts` 添加新模块初始化
2. 修改 `processMonitor` 函数，移除常规交易逻辑（保留浮亏检测）
3. 修改 `runOnce` 函数（保留末日保护同步执行）
4. 移除旧的 `signalVerificationManager` 相关代码
5. 更新 `MonitorContext` 类型定义

#### 阶段 6：集成测试与调优

1. 端到端测试完整交易流程
2. 验证延迟验证时间精度
3. 验证保护性清仓响应时间
4. 验证立即信号正确执行
5. 性能测试主循环执行时间
6. 压力测试多监控标的并发处理

---

## 八、关键设计约束

### 8.1 信号对象生命周期管理

信号对象使用对象池管理，需要明确各阶段的所有权和释放责任：

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              信号对象生命周期                                        │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│  主循环 (strategy.generateCloseSignals)                                             │
│                  │                                                                  │
│                  ├──────────────────────────────┬────────────────────────────────┐  │
│                  ▼                              ▼                                │  │
│         ┌────────────────────┐        ┌────────────────────┐                    │  │
│         │  立即信号          │        │  延迟信号          │                    │  │
│         │  (immediateSignals)│        │  (delayedSignals)  │                    │  │
│         └─────────┬──────────┘        └─────────┬──────────┘                    │  │
│                   │                             │                               │  │
│                   │ 直接入队                    │ 推入延迟验证器                │  │
│                   │                             │                               │  │
│                   ▼                             ▼                               │  │
│         ┌─────────────────────────┐   ┌─────────────────────────┐               │  │
│         │  任务队列               │   │  延迟验证器              │               │  │
│         │  (IMMEDIATE_SIGNAL)     │   │  (setTimeout 计时)       │               │  │
│         └─────────────────────────┘   └───────────┬─────────────┘               │  │
│                   │                               │                             │  │
│                   │               ┌───────────────┴───────────────┐             │  │
│                   │               ▼                               ▼             │  │
│                   │         验证失败                          验证通过          │  │
│                   │               │                               │             │  │
│                   │               ▼                               ▼             │  │
│                   │    延迟验证器释放信号              任务队列 (VERIFIED_SIGNAL)│  │
│                   │    signalObjectPool.release()           │                   │  │
│                   │                                         │                   │  │
│                   └────────────────────┬────────────────────┘                   │  │
│                                        │                                        │  │
│                                        ▼                                        │  │
│                          ┌─────────────────────────┐                            │  │
│                          │      交易处理器         │                            │  │
│                          │  (TradeProcessor)       │                            │  │
│                          └───────────┬─────────────┘                            │  │
│                                      │                                          │  │
│               ┌──────────────────────┼──────────────────────┐                   │  │
│               ▼                      ▼                      ▼                   │  │
│         执行成功                执行失败              风险检查拒绝              │  │
│               │                      │                      │                   │  │
│               └──────────────────────┴──────────────────────┘                   │  │
│                                      │                                          │  │
│                                      ▼                                          │  │
│                           交易处理器释放信号                                    │  │
│                           signalObjectPool.release()                            │  │
│                           (finally 块统一释放)                                  │  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

**释放责任明确**：

| 阶段 | 场景 | 释放责任方 |
|------|------|-----------|
| 立即信号 | 生成后 | 所有权转移至任务队列，不释放 |
| 延迟验证 | 验证失败 | 延迟验证器 (onRejected 回调) |
| 延迟验证 | 验证通过 | 所有权转移至任务队列，不释放 |
| 任务队列 | 出队传递 | 所有权转移至交易处理器，不释放 |
| 交易处理 | 处理完成（成功/失败/拒绝） | 交易处理器 (finally 块) |

### 8.2 行情数据来源

**设计决策**：交易处理器使用**主循环已获取的行情数据**，不重新调用 API。

**理由**：
1. 主循环每秒执行一次，行情数据足够新鲜
2. 交易处理器与主循环运行在同一事件循环中
3. 行情数据已通过 WebSocket 订阅实时更新到缓存

#### 8.2.1 行情数据传递机制（重要）

> **⚠️ 设计补充**：当前 `MonitorContext` 类型定义中没有行情缓存字段，需要扩展。

**方案：在 MonitorContext 中添加行情缓存字段**

```typescript
// 扩展 MonitorContext 类型定义（src/types/index.ts）
export type MonitorContext = {
  // ... 现有字段保持不变
  readonly config: MonitorConfig;
  readonly state: MonitorState;
  readonly strategy: HangSengMultiIndicatorStrategy;
  readonly orderRecorder: OrderRecorder;
  // ...
  
  // 【新增】行情缓存字段（每次主循环更新）
  /** 做多标的的最新行情（由主循环每秒更新） */
  longQuote: Quote | null;
  /** 做空标的的最新行情（由主循环每秒更新） */
  shortQuote: Quote | null;
  /** 监控标的的最新行情（由主循环每秒更新） */
  monitorQuote: Quote | null;
  
  // 【新增】持仓缓存字段（由主循环更新，供交易处理器使用）
  /** 做多标的的持仓（由主循环从 positionCache 提取） */
  longPosition: Position | null;
  /** 做空标的的持仓（由主循环从 positionCache 提取） */
  shortPosition: Position | null;
};
```

**主循环更新行情缓存**：

```typescript
// 在 processMonitorSimplified 中更新行情缓存
async function processMonitorSimplified(
  context: ProcessMonitorContext,
  quotesMap: ReadonlyMap<string, Quote | null>,
): Promise<void> {
  const { monitorContext, ... } = context;
  const { config } = monitorContext;

  // 1. 从预先获取的行情 Map 中提取行情
  const longQuote = quotesMap.get(config.longSymbol) ?? null;
  const shortQuote = quotesMap.get(config.shortSymbol) ?? null;
  const monitorQuote = quotesMap.get(config.monitorSymbol) ?? null;

  // 2. 【新增】更新 MonitorContext 中的行情缓存（供交易处理器使用）
  monitorContext.longQuote = longQuote;
  monitorContext.shortQuote = shortQuote;
  monitorContext.monitorQuote = monitorQuote;

  // 3. 【新增】更新持仓缓存
  const { longPosition, shortPosition } = getPositions(
    globalState.positionCache,
    config.longSymbol,
    config.shortSymbol,
  );
  monitorContext.longPosition = longPosition;
  monitorContext.shortPosition = shortPosition;

  // ... 后续处理
}
```

**交易处理器使用行情缓存**：

```typescript
private buildRiskCheckContext(signal: Signal, context: MonitorContext): RiskCheckContext {
  const { config, orderRecorder, riskChecker } = context;
  
  return {
    trader: this.trader,
    riskChecker,
    orderRecorder,
    // 使用 MonitorContext 中缓存的行情数据（主循环每秒更新）
    longQuote: context.longQuote,
    shortQuote: context.shortQuote,
    monitorQuote: context.monitorQuote,
    monitorSnapshot: context.state.lastMonitorSnapshot,
    longSymbol: config.longSymbol,
    shortSymbol: config.shortSymbol,
    longSymbolName: context.longSymbolName,
    shortSymbolName: context.shortSymbolName,
    // 用于日志显示的账户和持仓（不用于风险检查）
    account: null,  // 风险检查时会从 API 获取最新数据
    positions: [],
    lastState: this.lastState,
    currentTime: new Date(),
    isHalfDay: this.lastState.isHalfDay ?? false,
    doomsdayProtection: this.doomsdayProtection,
    config,
  };
}
```

#### 8.2.2 行情数据时效性保证

| 数据来源 | 更新频率 | 时效性 |
|---------|---------|--------|
| 主循环批量获取 | 每秒 1 次 | 最新 1 秒内 |
| WebSocket 推送 | 实时 | 毫秒级 |
| 信号对象携带 | 信号生成时 | 信号创建时刻 |

**数据新鲜度策略**：
- 风险检查的账户/持仓数据：买入操作从 API 实时获取，不使用缓存
- 行情数据：使用主循环缓存，足够新鲜（1 秒内）
- 持仓数据（用于卖出计算）：使用 positionCache 缓存

### 8.3 错误处理策略

**核心原则**：任何环节失败都直接拒绝交易，不进行重试。

| 环节 | 失败场景 | 处理方式 |
|------|---------|---------|
| 指标缓存查询 | 缺少必要的时间点数据 | 验证失败，释放信号 |
| 延迟验证 | 验证条件不满足 | 验证失败，释放信号 |
| 风险检查 | API 调用失败或检查不通过 | 拒绝交易，释放信号 |
| 订单执行 | 提交失败 | 记录日志，释放信号 |

**设计理由**：
1. 金融交易对确定性要求高，重试可能导致重复交易
2. 指标验证有时间窗口，重试时数据可能已过期
3. 保护性操作（浮亏清仓、末日保护）在主循环同步执行，不受影响

### 8.4 验证时间计算（重要）

**关键公式和常量**：

```typescript
// 常量定义（src/constants/index.ts）
VERIFICATION = {
  TIME_OFFSET_1_SECONDS: 5,      // T1 = T0 + 5秒
  TIME_OFFSET_2_SECONDS: 10,     // T2 = T0 + 10秒
  TIME_TOLERANCE_MS: 5000,       // 时间容差 ±5秒
  WINDOW_START_OFFSET_SECONDS: -5,  // 记录窗口开始 = T0 - 5秒
  WINDOW_END_OFFSET_SECONDS: 15,    // 记录窗口结束 = T0 + 15秒
  READY_DELAY_SECONDS: 15,       // 验证就绪延迟 = T0 + 15秒后执行验证
}
```

**时间线详解**：

```
                      信号生成时刻 (now)
                            │
                            │  strategy 计算 triggerTime = now + delaySeconds
                            │
                            ▼
┌───────────────────────────────────────────────────────────────────────────────┐
│                                                                               │
│  0s ─────────────────→ 55s ────────────→ 60s(T0) ──→ 65s(T1) ──→ 70s(T2) ──→ 75s
│  │                      │                  │                                 │
│  │                      │                  │     指标记录窗口                │
│  │                      │                  │     T0-5s 到 T0+15s             │
│  │                      │                  │                                 │
│  now                T0-5s=55s          triggerTime                    verifyTime
│  (信号生成)         (窗口开始)         (延迟时间点)                 (验证执行时刻)
│                                                                               │
│  delaySeconds = 60                     READY_DELAY_SECONDS = 15               │
│                                                                               │
└───────────────────────────────────────────────────────────────────────────────┘

总延迟 = delaySeconds(60) + READY_DELAY_SECONDS(15) = 75 秒
```

**⚠️ 易错点**：
- `triggerTime` 由 strategy 模块计算，**已经包含了 delaySeconds**
- 延迟验证器中 `verifyTime = triggerTime + READY_DELAY_SECONDS`
- **不要再加 delaySeconds**，否则会导致延迟时间翻倍！

---

## 九、风险与缓解措施

| 风险 | 级别 | 缓解措施 |
|------|------|----------|
| strategy 模块改造引入 bug | **高** | 阶段 0 必须先完成，编写完整单元测试验证立即信号/延迟信号分流 |
| 延迟验证时间精度不足 | 低 | setTimeout 精度约 1-15ms，对秒级操作足够 |
| 指标缓存数据丢失 | 中 | 验证前检查数据完整性，缺失时验证失败，拒绝交易 |
| 指标缓存按需提取遗漏指标 | 中 | 初始化时验证 indicatorsToCache 与验证配置一致 |
| 主循环与交易处理器状态不一致 | 中 | 使用共享状态 (lastState) + 原子操作 |
| 回归测试覆盖不足 | 中 | 编写完整的单元测试和集成测试 |

> **注意**：保护性清仓和末日保护保留在主循环中同步执行，无额外延迟风险。

### 9.1 strategy 模块改造风险详解

由于 strategy 模块改造是前置依赖，且涉及信号生成的核心逻辑，需要特别关注：

**潜在风险点**：
1. 改造后立即信号仍被丢弃（未正确修改返回逻辑）
2. 延迟信号误判为立即信号（条件判断错误）
3. 信号对象泄漏（立即信号未正确使用对象池）
4. 卖出信号的订单记录检查被意外移除

**测试验收标准**：

```typescript
describe('strategy 模块立即信号支持', () => {
  it('配置 delaySeconds=0 时应生成立即信号', () => {
    const config = {
      verificationConfig: {
        buy: { delaySeconds: 0, indicators: [] },
        sell: { delaySeconds: 0, indicators: [] },
      },
      // ... other config
    };
    const strategy = createHangSengMultiIndicatorStrategy(config);
    const result = strategy.generateCloseSignals(mockSnapshot, 'LONG', 'SHORT', mockRecorder);
    
    // 应有立即信号
    expect(result.immediateSignals.length).toBeGreaterThan(0);
    expect(result.delayedSignals.length).toBe(0);
    
    // 立即信号无 triggerTime
    expect(result.immediateSignals[0].triggerTime).toBeNull();
    expect(result.immediateSignals[0].indicators1).toBeNull();
  });

  it('配置 delaySeconds>0 且 indicators 非空时应生成延迟信号', () => {
    const config = {
      verificationConfig: {
        buy: { delaySeconds: 60, indicators: ['D', 'DIF'] },
        sell: { delaySeconds: 60, indicators: ['D', 'DIF'] },
      },
      // ... other config
    };
    const strategy = createHangSengMultiIndicatorStrategy(config);
    const result = strategy.generateCloseSignals(mockSnapshot, 'LONG', 'SHORT', mockRecorder);
    
    // 应有延迟信号
    expect(result.delayedSignals.length).toBeGreaterThan(0);
    expect(result.immediateSignals.length).toBe(0);
    
    // 延迟信号有 triggerTime
    expect(result.delayedSignals[0].triggerTime).not.toBeNull();
    expect(result.delayedSignals[0].indicators1).not.toBeNull();
  });

  it('买入和卖出可以配置不同的验证模式', () => {
    const config = {
      verificationConfig: {
        buy: { delaySeconds: 60, indicators: ['D', 'DIF'] },  // 延迟验证
        sell: { delaySeconds: 0, indicators: [] },            // 立即执行
      },
      // ... other config
    };
    const strategy = createHangSengMultiIndicatorStrategy(config);
    const result = strategy.generateCloseSignals(mockSnapshot, 'LONG', 'SHORT', mockRecorder);
    
    // 买入信号应为延迟信号，卖出信号应为立即信号
    const buySignals = [...result.immediateSignals, ...result.delayedSignals]
      .filter(s => s.action === 'BUYCALL' || s.action === 'BUYPUT');
    const sellSignals = [...result.immediateSignals, ...result.delayedSignals]
      .filter(s => s.action === 'SELLCALL' || s.action === 'SELLPUT');
    
    // 买入信号在 delayedSignals 中
    expect(result.delayedSignals.some(s => s.action === 'BUYCALL' || s.action === 'BUYPUT')).toBe(true);
    // 卖出信号在 immediateSignals 中
    expect(result.immediateSignals.some(s => s.action === 'SELLCALL' || s.action === 'SELLPUT')).toBe(true);
  });
});
```

---

## 十、预期收益

1. **主循环响应更快**：常规交易的 API 调用不再阻塞主循环
2. **保护性操作零延迟**：浮亏清仓和末日保护同步执行，确保实时响应
3. **职责更清晰**：数据生产 + 实时保护 vs 常规交易，分层明确
4. **更易维护**：各模块独立，修改一处不影响其他
5. **更易扩展**：添加新功能只需在对应层级修改
6. **架构更简洁**：无优先级队列，逻辑更直观
7. **配置灵活性**：支持买卖独立配置延迟验证，可按需关闭延迟验证（立即信号）
8. **动态缓存容量**：指标缓存根据配置自动调整，避免内存浪费或数据丢失
9. **修复立即信号支持**：解决当前 `delaySeconds=0` 时信号被丢弃的问题
10. **内存优化**：指标缓存按需提取，只存储配置中需要验证的指标，减少约 70% 内存占用

---

## 十一、回滚方案

如果重构过程中出现严重问题，可通过以下方式回滚：

1. 所有新模块在独立目录 `src/program/`，不影响 `src/core/` 原有代码
2. 主循环改造使用特性开关控制
3. 保留原有的 `signalVerificationManager` 代码（标记 deprecated）
4. Git 分支策略：在 `feature/refactor-main-loop` 分支开发

---

## 十二、附录

### A. 新增文件清单

```
src/program/                      # 新增目录：程序运行时架构
├── indicatorCache/               # 指标缓存（运行时基础设施）
│   ├── index.ts
│   ├── types.ts
│   └── utils.ts
├── tradeTaskQueue/               # 任务队列（运行时基础设施）
│   ├── index.ts
│   ├── types.ts
│   └── utils.ts
├── delayedSignalVerifier/        # 延迟验证器（运行时协调）
│   ├── index.ts
│   ├── types.ts
│   └── utils.ts
└── tradeProcessor/               # 交易处理器（运行时协调）
    ├── index.ts
    ├── types.ts
    └── utils.ts
```

> **目录设计说明**：
> - `src/core/` = 核心业务逻辑（策略、风险、订单、信号处理等可独立使用的业务组件）
> - `src/program/` = 程序运行时架构（缓存、队列、异步处理、任务调度等为主循环服务的运行时基础设施）
> - `src/services/` = 外部服务（行情客户端、技术指标计算等）
> - `src/utils/` = 工具函数

### B. 修改文件清单

```
src/
├── index.ts                          # 主循环改造，引入 program 模块
│                                     #   - 每秒更新 MonitorContext 中的行情缓存
│                                     #   - 每秒更新 MonitorContext 中的持仓缓存
├── types/index.ts                    # 【重要】扩展 MonitorContext 类型定义
│                                     #   - 新增 longQuote、shortQuote、monitorQuote 字段
│                                     #   - 新增 longPosition、shortPosition 字段
│                                     #   - 供交易处理器获取行情和持仓数据
└── core/
    ├── strategy/
    │   └── index.ts                  # 【重要】改造支持立即信号（前置依赖）
    │                                 #   - generateDelayedSignal → generateSignal
    │                                 #   - 添加 isImmediate 返回值
    │                                 #   - 【优化】信号类型预计算 signalTypeMap
    │                                 #   - 正确分流 immediateSignals 和 delayedSignals
    └── signalVerification/index.ts   # 标记 deprecated（由 program/delayedSignalVerifier 替代）
```

### C. strategy 模块改造检查清单

改造 `src/core/strategy/index.ts` 时需要确保以下功能：

- [ ] `generateSignal` 函数支持返回立即信号和延迟信号
- [ ] 立即信号的 `triggerTime` 为 `null`
- [ ] 立即信号的 `indicators1` 为 `null`
- [ ] 立即信号的 `verificationHistory` 为 `null`
- [ ] 延迟信号保持原有逻辑不变
- [ ] `generateCloseSignals` 正确将信号分流到 `immediateSignals` 和 `delayedSignals`
- [ ] 卖出信号的订单记录检查逻辑保持不变
- [ ] 信号对象正确使用对象池（acquire/release）
- [ ] 【优化】信号类型预计算 `signalTypeMap`（策略创建时计算一次）
- [ ] 【优化】`generateSignal` 中使用 `signalTypeMap[action]` 而非运行时条件判断

### D. 指标缓存模块检查清单

实现 `src/program/indicatorCache/` 时需要确保以下功能：

- [ ] 使用 `indicatorRecordPool` 对象池获取 `indicators` 对象
- [ ] 环形缓冲区覆盖旧条目前，释放旧的 `indicators` 对象回对象池
- [ ] `clear()` 和 `clearAll()` 方法释放所有 `indicators` 对象回对象池
- [ ] `extractConfiguredIndicators()` 返回的对象由调用方负责释放
- [ ] `getAt()` 方法选择**最接近目标时间**的数据（参考 `findBestMatch` 实现）
- [ ] 程序退出时调用 `clearAll()` 清理所有缓存

### E. MonitorContext 扩展检查清单

扩展 `src/types/index.ts` 中的 `MonitorContext` 类型时需要确保：

- [ ] 新增 `longQuote: Quote | null` 字段
- [ ] 新增 `shortQuote: Quote | null` 字段
- [ ] 新增 `monitorQuote: Quote | null` 字段
- [ ] 新增 `longPosition: Position | null` 字段
- [ ] 新增 `shortPosition: Position | null` 字段
- [ ] 主循环 `processMonitorSimplified` 中每秒更新这些字段
- [ ] 交易处理器 `buildRiskCheckContext` 中正确使用这些字段

### F. 相关文档

- [业务逻辑知识库](../.claude/skills/core-program-business-logic/SKILL.md)
- [技术指标文档](./TECHNICAL_INDICATORS.md)
- [TypeScript 规范](../.claude/skills/typescript-project-specifications/SKILL.md)
