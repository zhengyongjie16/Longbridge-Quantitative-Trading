# 交易日历预热起点重构方案评审与实施说明（2026-02-26）

## 1. 背景与问题定义

当前程序在启动/开盘重建阶段会出现如下告警：

- `[交易日历快照] 预热失败，将沿用当前快照并等待下一次重建`
- `response error: 7 ... code: 301600, msg: "too many query days"`

根因不是“获取全量订单”和“获取交易日历”两个 API 互相冲突，而是二者被错误地耦合了：

1. 先获取全量订单。
2. 用全量订单中的最早时间作为交易日历预热起点。
3. 导致交易日历查询窗口被历史已平仓订单无限拉长。
4. 触发交易日接口区间限制报错。

## 2. 现状链路与缺陷定位

### 2.1 现状链路

启动/重建主链路：

1. `loadTradingDayRuntimeSnapshot` 获取账户、持仓、全量订单。
2. 在该阶段直接执行 `prewarmTradingCalendarSnapshot`。
3. 预热起点为 `allOrders` 的最早 `submittedAt/updatedAt`。
4. 分块调用 `getTradingDays(startDate, endDate)`，当前块大小为 `180` 天。

### 2.2 设计缺陷

该实现存在三层语义错配：

1. **起点语义错配**：
   交易日历预热应服务于“当前仍持仓订单”的交易时长计算，但现状使用“历史全量最早订单”，把大量已平仓订单误纳入需求窗口。

2. **时序错配**：
   在 `loadTradingDayRuntimeSnapshot` 阶段尚未完成按席位/方向的订单重建，无法直接得到“当前仍持仓订单集合”，却提前决定预热窗口。

3. **接口约束错配**：
   分块大小 `180` 天与交易日接口单次区间限制不匹配，导致服务端拒绝。

## 3. 业务目标与必须满足的不变量

本次改造目标不是“减少告警”，而是恢复业务语义正确性。必须满足以下不变量：

1. 交易日历快照覆盖范围以“当前仍持仓订单”需求为准，而非历史已平仓订单。
2. 超时卖出与周期换标继续使用严格交易时段累计口径，不回退为自然时间。
3. 交易日历查询必须严格落在接口可接受范围内。
4. 当日历快照不足以保证口径正确时，系统不得带病继续交易。

## 4. 可行性分析

### 4.1 数据可得性可行

“当前仍持仓订单”在现有架构中是可得的：

1. `rebuildTradingDayState` 已在重建中按席位调用 `refreshOrdersFromAllOrdersForLong/Short`。
2. `orderRecorder.getBuyOrdersForSymbol(symbol, isLongSymbol)` 可直接读取过滤后的剩余买单。
3. 该集合正是智能平仓与超时判断的真实输入口径。

结论：可在重建阶段准确提取预热起点，无需额外 API。

### 4.2 生命周期接入点可行

将预热从 `loadTradingDayRuntimeSnapshot` 移到 `rebuildTradingDayState` 可行：

1. 启动流程本身就是 `load -> create contexts -> rebuild`。
2. 开盘重建同样走 `load -> rebuild`。
3. 在 `rebuild` 内执行预热，不破坏生命周期状态机与重试机制。

### 4.3 性能与复杂度可行

1. 读取仍持仓订单来自内存结构，复杂度低。
2. 交易日历查询改为按月分块，调用次数可控。
3. 相比现状“失败后反复重建告警”，整体稳定性与成本更优。

## 5. 合理性分析

### 5.1 业务合理性

以“仍持仓订单最早时间”作为预热起点，满足业务直觉与策略语义：

1. 已平仓历史单不再影响日历窗口。
2. 仍持仓老单会被完整覆盖，保证超时判断正确。
3. 与“严格交易时段累计”的设计目标一致。

### 5.2 架构合理性

1. `load` 负责原始快照拉取。
2. `rebuild` 负责语义重建与可交易态校准。
3. 交易日历预热属于“语义重建依赖”，放在 `rebuild` 更符合职责边界。

### 5.3 风险控制合理性

若日历快照不足，继续交易会导致超时与换标计时偏差。将预热失败升级为重建失败，由生命周期重试，符合“正确性优先”的交易系统原则。

## 6. 逻辑正确性论证

### 6.1 正确性命题 A：预热窗口最小充分

定义：

- `OpenOrders` = 当前所有仍持仓买单集合（按 monitor + direction + seat symbol 汇总）
- `t0` = `OpenOrders` 最早 `executedTime`
- `tn` = 当前时间 `now`

需要覆盖窗口应为 `[t0, tn + lookahead]`；若 `OpenOrders` 为空，退化为 `[tn - fallback, tn + lookahead]`。

该窗口是“最小充分”而非“历史最大”：

1. 比“全量最早订单”更小，避免无关历史放大。
2. 比“固定短窗”更稳健，保留长持仓正确性。

### 6.2 正确性命题 B：计算口径一致

超时判断、周期换标均依赖同一交易日历快照与同一累计函数。只要快照覆盖窗口满足命题 A，则两条链路同时保持正确。

### 6.3 正确性命题 C：失败不污染交易

当预热失败或所需窗口超出接口支持范围时，重建失败并阻断交易，避免“错误数据驱动交易决策”。这是唯一严格满足口径正确性的行为。

## 7. 系统性改造方案

## 7.1 改造原则

1. 不回退“交易日历快照机制”。
2. 不通过裁剪全量订单窗口（如 30 天）来规避问题。
3. 统一在重建阶段完成“仍持仓驱动的交易日历预热”。
4. 失败即重建失败，不做降级继续交易。

## 7.2 模块级改造清单

### A. `src/main/lifecycle/loadTradingDayRuntimeSnapshot.ts`

1. 移除 `prewarmTradingCalendarSnapshot` 调用。
2. 删除/下沉仅为该调用服务的旧起点计算逻辑。
3. 保留快照加载职责（账户、持仓、全量订单、席位准备、订阅）。

### B. `src/main/lifecycle/rebuildTradingDayState.ts`

新增重建步骤（建议放在 `rebuildOrderRecords` 之后、风险缓存重建之前）：

1. 从 `monitorContexts` 与当前 READY 席位提取仍持仓买单。
2. 计算 `demandStartMs`（最早仍持仓买单成交时间）。
3. 生成需求日期键区间并合并现有快照。
4. 调用 `marketDataClient.getTradingDays` 补齐缺失日期。
5. 写回 `lastState.tradingCalendarSnapshot`。
6. 预热失败抛错（由生命周期重试处理）。

### C. `src/main/lifecycle/types.ts`

如需解耦：

1. 为 `RebuildTradingDayStateDeps` 增加最小必要依赖（例如 `lastState` 已存在，可直接复用）。
2. 若引入独立预热器模块，则在 deps 中显式注入。

### D. （可选）新增模块

建议新增 `src/main/lifecycle/tradingCalendarPrewarmer.ts`：

1. 统一封装“仍持仓起点计算 + 分块拉取 + 快照合并”。
2. 降低 `rebuildTradingDayState.ts` 体积，便于单测。

## 7.3 查询分块策略（必须修正）

将“固定 180 天分块”改为“按自然月分块”或“严格不超过 1 个月分块”。

建议：

1. 以日期键构造分段，每段不跨超过 1 个自然月。
2. 每段调用 `getTradingDays(begin, end)`。
3. 仅对缺失日期键查询，避免重复请求。

## 7.4 边界约束（必须明确）

若仍持仓订单所需窗口早于接口可查询上限（例如超出最近一年）：

1. 直接抛出结构化错误。
2. 维持 `isTradingEnabled=false`（生命周期自动重试）。
3. 日志提示“需要人工处理（缩减超长持仓或补足可用数据）”。

该策略虽严格，但唯一保证口径不失真。

## 8. 为什么“只改 30 天全量订单”不可取

1. 不能从根上解决：30 天订单 + 未来 7 天仍可能超过接口单次窗口限制。
2. 会破坏重建正确性：若真实未平仓买单早于 30 天，成本、超时、恢复都将失真。
3. 会影响席位恢复：启动席位依赖历史成交归属，硬裁剪会降低恢复准确率。

结论：该做法属于“规避症状”，不满足系统性修复要求。

## 9. 测试与验收方案

## 9.1 单元测试

### `tests/main/lifecycle/rebuildTradingDayState.test.ts`

新增用例：

1. 仅已平仓历史单存在时，预热起点不回溯到该历史。
2. 存在仍持仓老单时，预热起点回溯到该老单。
3. 交易日查询分块均不超过 1 个月。
4. 预热失败时 `rebuildTradingDayState` 抛错。

## 9.2 调整旧测试

### `tests/main/lifecycle/loadTradingDayRuntimeSnapshot.test.ts`

1. 移除“从最早订单日期开始预热且不截断历史区间”的断言。
2. 改为验证 `load` 不承担交易日历预热职责。

## 9.3 集成测试

1. 跨日超时卖出：长持仓 + 半日市/非交易日场景，验证触发边界。
2. 周期换标：跨日累计分钟正确。
3. 生命周期：预热失败时重建重试，交易门禁保持关闭。

## 9.4 验收标准

1. 启动/重建不再出现 `301600 too many query days`。
2. 超时卖出与周期换标结果与交易时段累计口径一致。
3. 在快照不可用场景不发生带病交易。

## 10. 实施顺序

1. 抽离/重建预热器逻辑（仍持仓起点 + 分块拉取）。
2. 从 `loadTradingDayRuntimeSnapshot` 移除旧预热调用。
3. 在 `rebuildTradingDayState` 接入新预热步骤并改为 fail-fast。
4. 更新测试（load 测试与 rebuild 测试）。
5. 执行 `bun run lint`、`bun run type-check`、关键集成测试。

## 11. 最终结论

本方案在可行性、合理性和逻辑正确性上成立，且优于“缩短全量订单窗口”这类规避策略。

关键结论：

1. 缺陷确认为“预热起点语义错误 + 查询分块策略错误”。
2. 正确修复路径是“仍持仓驱动起点 + 重建阶段预热 + 严格分块 + 失败阻断交易”。
3. 按该方案实施后，可同时解决告警问题与业务口径一致性问题。
