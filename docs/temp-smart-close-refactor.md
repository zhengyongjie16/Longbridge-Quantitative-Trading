# 智能平仓方案 A 重构方案（临时文档）

日期：2026-01-23  
范围：`src/core/signalProcessor` 卖出逻辑、`orderRecorder` 相关查询、配置与文档说明  
目标：在“智能平仓开启”时不再检查成本价，直接执行“仅卖盈利订单”的智能平仓逻辑

---

## 1. 背景与目标（方案 A）

当前卖出信号处理在“智能平仓开启”时存在两级分支：若当前价高于持仓成本价则全仓清空；若未高于则仅卖出成交价低于当前价的订单。方案 A 的目标是简化并纯化智能平仓语义：**只要开启智能平仓，就始终执行“盈利订单部分卖出”**，不再使用成本价触发全清。  
这一调整把“智能平仓”从“盈利时可全清、否则只卖盈利订单”的混合策略，转换为一致的“盈利订单部分卖出”策略。该变化更符合“智能平仓=仅卖盈利部分”的直观定义，也减少了基于平均成本价的一次性全清行为。  
本重构强调系统性：明确语义、统一原因生成、梳理卖出决策的输入与输出边界，并保证业务逻辑单一来源（single source of truth），避免兼容性分支或补丁式代码。

---

## 2. 方案 A 详细分析

**核心行为变化**  
智能平仓开启时，卖出数量始终由“订单记录中成交价 < 当前价”的订单汇总计算，且最终卖出数量不超过可用持仓量。若无符合条件的订单或订单记录不可用，则信号转 HOLD。  

**收益**  
- 策略语义更单一：卖出信号只兑现已经盈利的仓位，避免以平均成本价为触发条件导致的“盈利全清”  
- 可读性与可解释性增强：卖出原因统一围绕“盈利订单筛选”而非“成本价比较”  

**风险与副作用**  
- 退出速度降低：即便总体盈利也不会全清，可能残留高价买入亏损仓位  
- 更依赖订单记录完整性：订单记录缺失或不完整时，卖出信号可能被 HOLD  
- 信号含义变化：原“反转/止损”信号变为“只兑现盈利部分”，需在文档明确  

**不受影响的保护机制**  
- 末日保护清仓与浮亏保护清仓不依赖成本价判断，仍可无条件清仓  

---

## 3. 系统性重构原则（避免补丁式逻辑）

1. **语义明确**：智能平仓 = 仅卖盈利订单；关闭智能平仓 = 全仓清空  
2. **单一决策入口**：卖出数量计算集中在统一函数，不分散到多处条件  
3. **最小输入依赖**：智能平仓不依赖成本价，仅依赖行情价、订单记录与可用数量  
4. **类型集中**：新增/调整类型放入 `src/core/signalProcessor/types.ts`  
5. **工具集中**：新增/调整工具函数放入 `src/core/signalProcessor/utils.ts`  
6. **日志一致性**：卖出原因文本与实际策略一致，避免“未高于成本价”等误导性描述  

---

## 4. 重构方案（更详细）

### 4.1 语义与文档同步（非兼容式）
- 更新 `.env.example` 与 `README.md` 中对 `SMART_CLOSE_ENABLED` 的描述  
- 移除“当前价高于成本价则全清”的文案  
- 明确：`true` = 仅卖盈利订单，`false` = 全仓卖出  

### 4.2 卖出决策结构重组（核心）
- 将 `calculateSellQuantity` 拆分为以下职责函数（纯函数 + 明确输入）  
  - `validateSellContext`：只验证 `availableQuantity` 与 `quote.price` 的有效性  
  - `resolveSellQuantityBySmartClose`：基于订单记录筛选盈利订单并计算数量  
  - `resolveSellQuantityByFullClose`：直接使用可用数量  
  - `buildSellReason`：统一生成原因文本（移除成本价比较）  
- `isValidPositionAndQuote` 调整为“不再要求 costPrice 有效”，避免在智能平仓路径中误判为无效  
- 保持依赖注入：所有外部依赖通过参数传入，不在内部创建  

### 4.3 智能平仓规则统一化
- 智能平仓开启：  
  - 直接调用 `orderRecorder.getBuyOrdersBelowPrice`  
  - 计算 `min(盈利订单总量, availableQuantity)` 作为卖出数量  
  - 无盈利订单 → HOLD  
- 智能平仓关闭：  
  - 直接卖出 `availableQuantity`  

### 4.4 订单记录与数量计算一致性
- 保持 `orderRecorder.getBuyOrdersBelowPrice` 为唯一盈利订单筛选入口  
- 确保 `recordLocalSell` 仍以“卖出价”过滤保留订单，与盈利订单卖出逻辑一致  
- 若需要新增计算函数，优先放在 `src/core/orderRecorder/utils.ts` 中，避免分散计算逻辑  

### 4.5 日志与原因文案系统化
- 新原因模板示例：  
  - `智能平仓：当前价=xxx，卖出盈利订单数量=yyy`  
  - `智能平仓：无盈利订单，保持持仓`  
  - `智能平仓：订单记录不可用，保持持仓`  
- 删除与成本价比较相关的文本  

---

## 5. 具体改动清单（文件级）

**核心逻辑**  
- `src/core/signalProcessor/index.ts`：移除成本价全清分支，重构卖出数量计算流程  
- `src/core/signalProcessor/utils.ts`：调整验证函数与新增卖出决策工具函数  
- `src/core/signalProcessor/types.ts`：补充卖出决策相关类型（若新增）  

**文档与配置说明**  
- `.env.example`：更新智能平仓说明  
- `README.md`：同步卖出策略描述  

---

## 6. 测试与验证（实施阶段执行）

- 补充单元测试（若已有测试框架）  
  - 智能平仓开启：有盈利订单 / 无盈利订单 / 订单记录缺失  
  - 智能平仓关闭：全清路径  
  - 可用数量不足时的 `min` 行为  
- 运行：`npm run lint` 与 `npm run type-check`  

---

## 7. 非目标与约束

- 不引入兼容性分支或“临时保留旧逻辑”的补丁  
- 不引入新的策略模式开关（保持方案 A 的语义单一性）  
- 不修改保护性清仓与末日保护清仓的无条件逻辑  
